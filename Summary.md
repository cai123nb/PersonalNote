# 面试总结

## 面试技巧

### 工作介绍

+ 负责CIM系统开发和维护, 保证系统24小时可靠稳定运行.
+ 维护生产管理，设备管理和品质管理等模块自动化运行和动态监控.
+ 和机台厂商,生产制造部门协商确定需求, 制定开发文档, 进行项目开发.

### 项目介绍

+ WIM智能办公系统(自己只是开发的一部分人员, 符合开发的基本规范, 假设存在一个前端, 一个组长, 自己作为后台开发) 开发流程: 收集需求, 指定需求说明文档, 制作原型, 开发第一版, 快速迭代.

+ BC系统向Java转型

### 离职原因

+ 职业发展方向不一样, 公司方向偏向于把我们培养成业务骨干, 维持生产的正常进行. 个人方向软件架构师(软件架构师是软件行业中一种新兴职业，工作职责是在一个软件项目开发过程中，将客户的需求转换为规范的开发计划及文本，并制定这个项目的总体架构，指导整个开发团队完成这个计划。主导系统全局分析设计和实施、负责软件构架和关键技术决策的人员.)

+ 工作偏运维, 技术相对保守稳定, 有一个现成的系统, 挑战性比较小. 个人喜欢挑战自己, 积极学习新的东西.

## 学习总结

### 深度

+ JDK源码尽快阅读(重点放在多线程那部分)
+ Mysql相关SQL调优学习

### 广度学习

+ Spring Cloud
+ OSGI了解并使用
+ Elasticsearch使用和应用
+ activiti工作流

## 刷题补基础

### 自我和项目相关

#### 自我介绍

大家好，我叫蔡剑勇，毕业于西南大学软件工程专业. 个人性格外向偏理性，容易相处，喜欢学习新事物，挑战自己。平时喜欢看书和健身. 在工作之余,会在个人网站上面更新自己的技术博客, 在开源社区和他人讨论技术问题.

#### 你觉得自己的优点是？你觉得自己有啥缺点？

优点有: 学习能力强, 适应性强: 在任何环境中都能很快适应下来, 并投入工作. 喜欢挑战自己: 喜欢尝试不同的事物, 挑战自己的极限. 团队协作性好: 可以较快地融入团队工作中,并贡献自己的一份力.

缺点有: 性格有时候有点急, 碰到一件事第一个想法就是马上解决, 不喜欢拖延.

#### 你有哪些 offer？

无.

#### 你为什么要离开上家公司？你上家公司在xxx，我们公司在xxx，离这么远为什么要选择我们这里？

+ 主要是职业发展方向不一样, 虽然上家公司也是很好的, 无论是技术方向和前景都是很不错的. 上家公司主要方向偏向于走物联网和工业互联网方向, 而我所在的岗位主要是负责物联的方向: 就是和机台通信, 自动化生产的方向. 这个对硬件的要求比较高, 侧重点在于如何把硬件和软件结合起来, 在维持生产的正常进行时, 来进行系统的开发. 而我个人的方向还是偏向喜欢纯软件, 个人方向还是想往软件架构师方向发展.(软件架构师是软件行业中一种新兴职业，工作职责是在一个软件项目开发过程中，将客户的需求转换为规范的开发计划及文本，并制定这个项目的总体架构，指导整个开发团队完成这个计划。主导系统全局分析设计和实施、负责软件构架和关键技术决策的人员.)

+ 第二就是公司技术相对保守稳定, 存在现成的系统, 对我来说挑战性比较小, 比如学习2-3个月, 就可以一直正常的工作了. 而我个人喜欢挑战自己, 积极学习新的东西.

#### 上家公司的同事和领导是怎么评价你的？

认真负责: 只要事情经过我的, 我都会持续跟踪下去.

#### 介绍下你的上家公司是做哪块的吧

+ 第一块就是负责CIM系统开发和维护, 保证系统24小时可靠稳定运行, 而我们也开发了各种各样的模块进行管理: 生产管理模块，设备管理模块和品质管理模块等等进行生产的监控.

+ 第二块主要是相关办公系统的开发, 开发部门相关的办公系统, 运维系统等.

#### 在上家公司你做了哪些项目？

+ WIM智能办公系统(自己只是开发的一部分人员, 符合开发的基本规范, 假设存在一个前端, 一个组长, 自己作为后台开发, 开发流程: 收集需求, 指定需求说明文档, 制作原型, 开发第一版, 快速迭代.)部门级别办公辅助系统, 提供运维信息管理,Issue录入,周报生成,工作量统计等多项辅助功能.

+ BC系统向Java转型, BC系统就是管理产线的系统, 每一个产线对应一个BC系统, BC系统控制着各种生产相关管理, 何时上货,何时下货,什么时候跑什么货等. 几百个BC系统连接在一起就变成我们现在的CIM系统. 之前的BC系统是使用C#编写的, 是跑在WindowsServer下使用SQL Server, FTP等进行部署的. 但是这个系统存在比较多的问题, 其中一个如:当我们要更新BC系统,上线新的需求的时候, 我们就必须停止产线生产, 这会造成严重的损耗. 后期我们的规划是转化为Java方向, 使用Linux+Java+Web的形式进行开发部署, 更新时通过OSGI进行无痛换版.

#### 你在项目中是什么角色？

WIM智能办公系统中主要是后台开发, 为前端提供Restful的方法调用. 有时候会协助前端进行页面撰写.

BC系统向Java转型项目, 主要是项目负责人.

#### 这个项目的数据量和并发量多大？

WIM智能办公系统就是传统的Web端的项目, 数据量和使用量为部门级别, 一共有4-5百人在使用, 高峰并发量可能达到100TPS.

BC系统向Java转型这个和传统的Web项目不太一样, 产线时时刻刻都在产生信息, 一个产品从上货到下货的需要成百上千的指令支持, 如上货请求, 上货信息下载, 开始命令等. 除了这些指令, 我们系统还需要定时收集机台信息, 产品信息进行后台动态监控等. 高峰交互可以达到500TPS.

#### 这个项目用的什么技术？

WIM智能办公系统: Spring Boot + Vue + SQL Server

BC系统向Java转型: Spring + Tomcat + OSGI

#### 项目过程中有遇到什么很印象深刻的问题吗？

BC系统向Java转型这个项目, 因为这个项目之前是C#写的, 要完全改写成Java版本, 就必须全部阅读底层代码, 明白它的系统架构和代码实现等. 之前接触过C#, 但是需要阅读一个完全用C#完成的系统, 这个挑战性还是很大的.

#### 是怎么解决的这些问题？

学习C#, 然后代码一行一行的看, 不同的就google对应的C#语法情况.

#### 项目有没有还可以继续优化的地方？

有时候BC系统的监控信息交互都是实时的, 这对BC系统有很多的负载请求. 而有些情况对及时性又不是非常严格的, 这时候使用一些合理的中间件, 如RabbitMQ, Kafaka进行中间转发,将会很好的解决这个问题.

对于有些BC系统中某些常用的信息, 如机台信息等都是可以使用内存数据库进行缓存的, 而不是直接访问数据库, 这时候可以使用Redis进行合理的应用.

#### 该怎么优化？有什么思路没？

同上.

#### 叫你设计一个并发xxx，数据存储量xxx 量级的系统，你该如何设计？从你知道的点尽可能的多说出些？

Spring Cloud.

### Java 基础

#### Object 对象的方法有哪些？分别有什么作用？该什么场景用？

+ getClass: 返回对象的Class类型
+ hashCode: 返回对象的哈希值
+ equals: 判断两个对象是否相等, 默认实现为引用判断
+ clone: 返回对象的拷贝, 深拷贝
+ toString: 字符串描述
+ notify: 唤醒等待该对象监视器的线程, 如果有多条线程, 随机唤醒一条.
+ notifyAll: 唤醒所有等待对象的监视器的线程.
+ wait: 线程放弃对象监视器所有权, 进入等待池中, 并等待唤醒.
+ finalize: 析构函数,当对象被回收时, 默认调用该函数.

#### Integer 的常量缓存池

默认缓存-128到127之间的Integer对象, 可以通过-XX:AutoBoxCacheMax设定上限.

#### Java 特性？什么是多态？举个例子

面向对象编程: 封装(相关信息操作封装起来,对外提供接口), 继承(通过继承可以获取父类的操作), 多态(动态绑定, 声明一个接口或者父类, 具体的实现由不同的子类完成.), 抽象(把事物的特征抽象成属性和方法).

#### 重载重写的区别？

重载: 相同方法名, 但是参数特征不一致.

重写: 覆盖父类的实现, `@Override`标识.

#### 画下 HashMap 的结构图？HashMap 、 HashTable 和 ConcurrentHashMap 的区别？使用场景分别是？

HashMap,HashTable: 数组 + 链表 . Java8新加功能: HashMap对于数组内的单个元素链表非常多(默认超过7个)的话, 将链表转化为红黑树(根节点为黑色, 黑色节点的子节点可以红或者黑, 红色节点的子节点一定为黑色, 保证根节点到达任何一个子节点的路径中黑色节点数量相同, 通过树的选择来实现), 而HashTable不会.

HashTable: 线程安全的, 读或者取都是需要获取对象实例锁, 效率较低.

ConcurrentHashMap: 线程安全的, HashTable的优化版本, 和HashTable提供相同的接口. Java7: 内部数据存在一个Segment数组中, 大小为16, Segment对象内部和HashMap类似, 为数组+链表, 内部可以扩容. 读取不加锁, 修改值的时候, 必须获取Segemnt的锁, 理论上最大支持16个线程同时修改. Java8: 实现还是使用数组+链表的实现方式(链表可能转变为红黑树), 通过对数组中链表的头结点进行加锁来保证同步性.

#### HashMap 中怎么解决冲突的？

取哈希值放到不同的桶里面, 如果存在的话, 以链表的形式挂在后面. 数量超过7个, 则转化为红黑树结果.

#### ConcurrentHashMap 和 HashTable 中线程安全的区别？为啥建议用 ConcurrentHashMap ？能把 ConcurrentHashMap 里面的实现详细的讲下吗？

HashTable: 线程安全的, 读或者取都是需要获取对象实例锁, 效率较低.

ConcurrentHashMap: 线程安全的, HashTable的优化版本, 和HashTable提供相同的接口. Java7: 内部数据存在一个Segment数组中, 大小为16, Segment对象内部和HashMap类似, 为数组+链表, 内部可以扩容. 读取不加锁, 修改值的时候, 必须获取Segemnt的锁, 理论上最大支持16个线程同时修改. Java8: 实现还是使用数组+链表的实现方式(链表可能转变为红黑树), 通过对数组中链表的头结点进行加锁来保证同步性.

#### 保证线程安全的还有其他的方式吗？

Synchronize, CAS, ThreadLocal,设计类为不变类,Volatile(只保证了可见性和有序性,不能保证原子性).

#### 讲下 Synchronized？

对象添加一个监视器锁, 每次进入时通过检查是否获取监视器锁.

#### 讲下 ReentrantLock 可重入锁？ 什么是可重入锁？为什么要设计可重入锁？

可重入锁: 获取锁的线程可以重复进入, 每次进入计数+1, 出去计数-1, 计数为0, 释放锁.

如果一个线程需要重复进入某个同步方法, 就会重复获取线程锁, 就会导致死锁.

ReentrantLock: 代码实现的, 可以指定: 公平锁和非公平锁, 可以指定Condition分组需要唤醒的线程(而不是像Synchronize随机唤醒), 提供中断等待的方法(而Synchronize无法中断).

Synchronize: JVM底层实现. 自从优化之后, 加入轻量级锁,偏向锁之后性能相差不多. 当需要使用上面三个特性时可以使用.

#### Synchronized 和 RecentLock 有什么区别？这两个有没有深入了解源码？

ReentrantLock: 代码实现的, 可以指定: 公平锁和非公平锁, 可以指定Condition分组需要唤醒的线程(而不是像Synchronize随机唤醒), 提供中断等待的方法(而Synchronize无法中断).

Synchronize: JVM底层实现. 自从优化之后, 加入轻量级锁,偏向锁之后性能相差不多. 当需要使用上面三个特性时可以使用.

#### 讲下 Volatile 吧？他是怎样做到同步的？

Volatile(只保证了可见性和有序性,不能保证原子性), 原理:每次修改该值, 都会强制让缓存中的该值失效, 必须重新从主存获取. 根据Happen-before原则, volatile变量的写入先于读取操作.

#### Volatile 为什么不支持原子性？举个例子

volatile a = 0;
a++;

#### Atomic 怎么设计的？有用过里面的类吗？

CAS设计, for循环中使用CAS进行设置.

#### 线程安全类和线程不安全的类，项目使用的时候你会怎么选择？怎么判断项目代码哪里会有线程不安全问题？

是否存在被多个线程访问的风险, 如果存在进行同步化操作.

#### Map、List、Set 分别说下你了解到它们有的线程安全类和线程不安全的类？

Map: HashMap, - ConcurrentHashMap, HashTable,Collections.synchronizedMap()
List: ArrayList, LinkedList -  Vector, Collections.synchronizedList(), CopyOnWriteArrayList,
Set: HashSet - CopyOnWriteHashSet, Collections.synchronizedSet()

#### TreeSet 清楚吗？能详细说下吗？

TreeSet: 底层就是TreeMap, 使用红黑树的操作

#### ThreadLocal 了解吗？项目有用过吗？可以说说

为每一个线程单独存储变量, 空间换时间. 变量存在线程实例内部的ThreadLocalHashMap中, key为ThreadLocal, 内部存储对应的变量. 该Map中使用WeakReference, 保证线程消除时, 对应的引用也会消失.

#### JUC 里面你还知道什么其他的类吗？比如 CountDownLatch、Condition

Condition: 功能类似Object, wait,notify. 可以用于区分不同的线程, 进行分组操作.

CountDownLatch: 特殊的锁, 当内部存在一个计算, 计数为0时, 释放所有堵塞的线程. 一般用于测试和等待初始化操作.

#### 从源码详细说下 Java 里面的线程池吧，使用线程池有什么要注意的地方？你们公司有规范吗？

ThreadPoolExecutor: corePoolSize, maximumPoolSize, keepAliveTime(线程数量大于corePoolSize才生效), workQueue, threadFactory, handler(拒绝策略).

一个任务提交过来, 如果线程数小于corePoolSize, 创建线程进行运行. 否则添加到队列中. 如果队列满了, 就会使用拒绝策略.

newFixedThreadPool: 固定线程数量, 队列长度为Integer.MAX, 容易出现OOM.
newSingleThreadExecutor: 同上.
newCachedThreadPool: 固定线程数量为0, 线程数量为Integer.MAX, 线程数量达到系统限制容易导致OOM.
newScheduledThreadPool: 定时执行线程池. 

### JVM

#### JAVA 类加载器

+ Bootstrap类加载器 – JRE/lib/rt.jar

+ Extension类加载器 – JRE/lib/ext或者java.ext.dirs指向的目录

+ Application类加载器 – CLASSPATH环境变量, 由-classpath或-cp选项定义,或者是JAR中的Manifest的classpath属性定义.

采用委托模型进行加载, 优先让父类加载器进行加载. 在JVM虚拟机中类的标识为: 类标识 + 类加载器. 通过不同类加载器来加载同一个类可以区分不同的类版本, 常被用于热替换.

#### Java 内存结构（注：不是 Java 内存模型，别搞混）

线程私有: 程序计数器(存储当前方法执行的位置) + 虚拟机栈(每创建一个线程就会携带一个虚拟机栈, 用于执行方法(栈帧(方法名称,方法类等)), 后入先出) + 本地方法栈(用于非Java方法, Native方法,类似虚拟机栈)

线程共有: 方法区(存储类结构相关信息: 常量,静态变量,构造函数等) + 堆(存储Java实例)(年轻代(2Sur(from - to) + 1Eden) + 老年代)

每个实例对象初始化的时候, 默认在Eden分配, 每次MinorGC时, 将Eden区实例对象移动到to区内, from区对象检查年龄, 如果超过一定的大小移动到老年代, 没有超过移动到to区.这时候将from和to身份互换.

#### 怎么判断对象是否可 GC？Java 对象有哪些引用类型？有什么区别？

可达性分析算法

在主流的商用程序语言(Java, C#, Lisp)的主流实现都是通过可达性分析(ReachabilityAnalysis)来判断对象是否存活. 基本思想: 通过一系列的称为GC Roots的对象作为起始点, 从这些节点开始向下搜索, 搜索所走过的路径称为引用链(Reference Chain). 当一个对象到GC Roots没有任何引用链相连时(即GC Roots到这个对象不可达), 则证明这个对象是不可用的. 在Java中, 可作为GC Roots的对象有:

+ 虚拟机栈(本地变量表)中引用的对象
+ 方法区中类静态属性引用的对象.
+ 方法区中常量引用的对象.
+ 本地方法栈JNI(一般来说的Native方法)应用的对象.

引用类型:

+ 强引用: Strong Reference, 类似Object obj = new Object(), 平时代码中普遍存在的. 只要强引用还存在, 垃圾收集器永远不会回收掉被引用的对象.
+ 软引用: Soft Reference, 描述一些有用但并非必需的对象. 在系统将要发生内存溢出异常之前, 将会把这些对象进行回收, 如果这次回收后还没有足够的内存, 才会抛出内存溢出异常. Java使用SoftReference类来实现软引用.
+ 弱引用: Week Reference, 描述非必需对象, 强度比Soft Reference弱一些, 被弱引用关联的对象只能生存到下一次垃圾收集发生之前. 当垃圾收集器工作, 无论当前内存是否足够, 都会回收掉只被弱引用关联的对象. Java中提供WeakReference类来实现弱引用.
+ 虚引用: Phantom Reference, 最弱的一种引用, 一个对象无论是否存在虚引用, 完全不会对其生存时间构成影响, 也无法通过虚引用取得一个对象的实例. 设置虚引用的唯一目的就是能在对象被收集器回收时收到一个系统通知. Java中提供PhantomReference类来实现虚引用.

#### OOM 出现的有哪些场景？为什么会发生？

虚拟机栈和本地方法栈: 栈进行动态拓展, 拓展时无法申请到足够的内存, 就会抛出OutOfMemoryError异常.

Java堆: (-Xmx,-Xms)如果堆中没有内存完成实例分配, 并且堆也无法拓展时,就会抛出OutOfMemeoryError异常.

方法区: 方法区无法满足内存分配需求时, 抛出OutOfMemoryError异常.

#### Minor GC 和 Full GC 有什么区别？分析过 GC 日志吗？

Minor GC: 新生代无法分配对象地址, 进行GC操作.(如Eden区满了, 无法分配对象)

Full GC: 整理整个堆的信息, 如新生代对象转移到老年代的时候, 空间不够而触发.

#### 说下你知道的垃圾回收算法

+ 标记-清除算法: 先标记, 后统一清除.
+ 复制算法: 分两半, 每次用一半, 拷贝存活到另一端.
+ 标记-整理: 先标记, 后整理.
+ 分代收集算法: 年轻代(Eden + 2Sur) + 老年代.

#### 说下你知道的垃圾收集器

年轻代:

+ Serial收集器: 串行化(单线程) + Stop the world(适合客户端内存不大)
+ ParNew收集器: Serial收集器的多线程版本.
+ Parallel Scavenge收集器: 复制算法 + 多线程 + 以吞吐量为目标(运行用户代码时间百分比)

老年代:

+ Serial Old收集器: 单线程 + 标记整理算法
+ Parallel Old收集器: 配合Parallel Scanvenge收集器 + 多线程 + 标记整理 + 以吞吐量为目标
+ CMS收集器: 最短停顿时间为目标 + 3次标记1次清除(1,3次标记Stop The World, 2次并发标记) + 标记清除

共用G1收集器:

+ 并行与并发: GI可以充分利用多CPU, 多核环境下的硬件优势, 使用多个CPU来缩短Stop-The-World的停顿时间, 部分其他收集器原本需要停顿Java线程执行的GC动作, G1收集器仍然可以通过并发的方式让Java程序继续执行.
+ 分代收集: 与其他收集器一样, 分代的概念在G1中依然可以保留. 虽然G1可以不需要其他收集器配合就能独立管理整个GC堆, 但它能够采用不同的方式去处理新创建的对象和已经存活了一段时间, 熬过了多次GC的旧对象以获得更好的收集效果.
+ 空间整合: 与CMS的标记-清理算法不同, G1从整体来看是基于标记-整理算法实现的收集器, 从局部(两个Region之间)上来看是基于复制算法实现的, 但无论如何, 这两种算法都意味着G1运行区间不会产生内存空间碎片.
+ 可预测的停顿: 这是G1相对CMS的另一大优势,降低停顿时间是G1和CMS共同的关注点, 但G1除了追求低停顿外, 还能建立可预测的停顿时间模型, 可以让使用者明确指定在一个长度为M毫秒的时间片段内, 消耗垃圾收集上的时间不得超过N毫秒, 这几乎已经是实时Java(RTSJ)的垃圾收集器的特征了.

#### CMS 和 G1 的区别知道吗？使用场景分别是？你项目中用的是哪个？

CMS收集器: 最短停顿时间为目标 + 3次标记1次清除(1,3次标记Stop The World, 2次并发标记) + 标记清除 (适合快速响应的Web后台服务), 用于老年代收集.

G1收集器: 同时处理老年代和新生代, 未来的标准, JDK9默认使用. 具有:

+ 并行与并发: GI可以充分利用多CPU, 多核环境下的硬件优势, 使用多个CPU来缩短Stop-The-World的停顿时间, 部分其他收集器原本需要停顿Java线程执行的GC动作, G1收集器仍然可以通过并发的方式让Java程序继续执行.
+ 分代收集: 与其他收集器一样, 分代的概念在G1中依然可以保留. 虽然G1可以不需要其他收集器配合就能独立管理整个GC堆, 但它能够采用不同的方式去处理新创建的对象和已经存活了一段时间, 熬过了多次GC的旧对象以获得更好的收集效果.
+ 空间整合: 与CMS的标记-清理算法不同, G1从整体来看是基于标记-整理算法实现的收集器, 从局部(两个Region之间)上来看是基于复制算法实现的, 但无论如何, 这两种算法都意味着G1运行区间不会产生内存空间碎片.
+ 可预测的停顿: 这是G1相对CMS的另一大优势,降低停顿时间是G1和CMS共同的关注点, 但G1除了追求低停顿外, 还能建立可预测的停顿时间模型, 可以让使用者明确指定在一个长度为M毫秒的时间片段内, 消耗垃圾收集上的时间不得超过N毫秒, 这几乎已经是实时Java(RTSJ)的垃圾收集器的特征了.

#### 你还知道哪些 JVM 调优参数？

+ -Xmx -Xms固定堆的大小, 防止Java应用在运行时动态拓展,导致卡顿.
+ `-XX:+ DisableExplicitGC`: 设置关闭程序`System.gc()`.
+ 选择合理的垃圾收集器: 如果是高性能多核处理器, 如果以吞吐量为目标使用`Parallel Scanvenge + Parallel Old`通过这个命令: `-XX:+UseParallelGC, -XX:+UseParallelOldGC`, 如科学计算, 后台运行等. 如果以最短响应时间为目标, 使用`ParNew + CMS`垃圾收集器.

详细设置:

```c
堆设置

-Xms：初始堆大小

-Xmx：最大堆大小

-XX:NewSize=n：设置年轻代大小

-XX:NewRatio=n：设置年轻代和年老代的比值。如：为3，表示年轻代与年老代比值为1：3，表示Eden：Survivor=3:2，一个Survivor区占整个年轻代的1/5。

-XX:MaxPermSize=n：设置持久代大小

收集器设置

-XX:+UseSerialGC：设置串行收集器

-XX:+UseParallelGC：设置并行收集器

-XX:+UseParalledlOldGC：设置并行年老代收集器

-XX:+UseConcMarkSweepGC：设置并发收集器

垃圾回收统计信息

-XX:+PrintGC

-XX:+PrintGCDetails

-XX:+PrintGCTimeStamps

-Xloggc:filename

并行收集器设置

-XX:ParallelGCThreads=n：设置并行收集器收集时使用的CPU数。并行收集线程数。

-XX:MaxGCPauseMillis=n：设置并行收集最大暂停时间

-XX:GCTimeRatio=n：设置垃圾回收时间占程序运行时间的百分比。公式为1/(1+N)

并发收集器设置

-XX:+CMSIncrementalMode：设置为增量模式。适用于单CPU情况。

-XX:+ParallelGCThreads=n：设置并发收集器年轻代收集方式为并行收集时，使用的CPU数。并行收集线程数。
```

#### 假如线上服务发生 OOM，有哪些措施可以找到问题？

#### 假如线上服务 CPU 很高该怎么做？有哪些措施可以找到问题？

+ 首先使用top命令(输入大写P按照CPU排序)定位CPU占用率高的进程ID,确定是否为Java程序.
+ 使用`top -Hp ID号`, 查看该进程所有的线程信息, 输入大写P进行CPU排序, 定位内存最大的线程ID号.
+ `printf "%x\n" 线程ID号` 转换为十六进制的线程ID号.
+ `jstack 进程ID号 | grep '0x十六进制线程ID号' -C5 --color`, 确定线程的具体功能.

#### 假如线上应用频繁发生 Full GC，有哪些措施可以找到问题？

生成GC文件(-XX:+PrintGCDetails或者使用jstat -gc 1100 1000 1000动态打印出来)

FULL GC的触发情况:

+ 调用System.gc. 如果GC日志中包含很多`Full GC(System)`标识, 可以通过`-XX:+ DisableExplicitGC`来显式禁用.
+ 老年代空间不足, 这时候就需要分析具体什么对象占据大部分的内容而不被清除了. 通常使用`jvisualvm`, 在里面可以进行`heap dump`和`thread dump`实时查看各类数据. 如果使用`heap dump`可能影响当前的运行的线程.
+ 方法去空间不足, 这个一般较少出现, 一般是在初始化的时候加载过多的类, 同时方法区设置过小导致. 查看方法区的占用, 将其设置大点. 同第二点.
+ 通过Minor GC后进入老年代的平均大小大于老年代的可用内存. 同第二点.

#### 一般线上环境遇到 JVM 问题，你会使用哪些工具来分析？找到问题后又该如何去解决呢？

如果是CPU暂用过大, 使用`top`定位CPU内存最大的进程和线程, 然后使用`jstack`查看线程的具体的信息.

如果是内存过大的话, 查看GC日志和使用`jvisualvm`进行观察.

### Spring

#### 说下你对 Spring 生态的了解？

+ Spring Boot：一站式快速开发解决项目。

+ Spring Cloud：提供对分布式系统的支持。

+ Spring Data：提供对主流的关系型及NOSQL型数据库的封装支持。

+ Spring Security：支持系统授权、认证的支持。

+ Spring Session：提供对session管理的支持。

+ Spring Batch：提供对大数据的批处理简化处理优化的支持。

+ Spring Social：提供对社交网络API的集成，如FACEBOOK、新浪微博等。

+ Spring AMQP：提供对AMQP的消息支持。

+ Spring LDAP：提供并简化使用LDAP的支持。

+ Spring XD：用来简化对大数据应用开发。

+ Spring Integration：通过消息机制对企业集成模式EIP的支持。

+ Spring Mobile：支持对手机设备检测等功能。

+ Spring for Android：提供在安卓平台消费restful api的支持。

+ Spring Web Flow：基于spring mvc提供对向导流程式的开发。

+ Spring Web Services：提供基于SOAP/Web协议服务支持。

#### 说下你对 Spring AOP 和 IOC 的理解？看过实现原理吗？

`IOC`: Inversion of Control, 当某个角色需要另外一个角色协助的时候，在传统的程序设计过程中，通常由调用者来创建被调用者的实例。但在spring中创建被调用者的工作不再由调用者来完成，因此称为控制反转。创建被调用者的工作由spring来完成，然后注入调用者. 因此也称为依赖注入。spring以动态灵活的方式来管理对象 ， 注入的两种方式，设置注入和构造注入。 设置注入的优点：直观，自然. 构造注入的优点：可以在构造器中决定依赖关系的顺序.

`AOP`: 面向对象编程将程序分解成各个层次的对象，面向切面编程将程序运行过程分解成各个切面。面向切面编程，通过`预编译方式`和`运行期动态代理(Java代理,Cglib)`实现程序功能的统一维护的一种技术。在不影响原来功能代码的基础上，使用动态代理加入自己需要的一些功能（比如权限的验证，事务的控制，日志的记录等等），移除之后，并不影响原来的功能. 底层通过`ASM`实现, Java代理, 通过让代理类和原来类都实现同一个接口. Cglib: 让代理类继承原来类. 都可以保证不侵染代码, 保证代码的纯洁性. 一般通过注解和xml注释来实现.

#### 说下 Bean 在 Spring 中的生命周期？

+ BeanFactory初始化之后, 读取XML或者读取注解获取对应的Bean信息.
+ 初始化BeanPostProcessor, 存在钩子函数(postProcessBeforeInstantiation), 然后通过BeanPostProcessor通过反射调用Bean的构造函数.
+ 动态注入各类信息, 如果Bean类实现了类似`BeanFactoryAware,BeanNameAware,InitializingBean,DisposableBean`接口, 也需要注入相关的信息.
+ 这时Bean正式准备好了, 可以使用, 直到容器初始化.
+ 容器关闭, 调用Bean的`DiposibleBean.destroy()`方法和`destroy-method`方法.

#### 讲下你知道的 Spring 注解有哪些？该什么场景使用？

+ 组件类: `@Component`,`@Repository`,`@Controller`,`@Service`,`@Bean`: 标明一个Spring Bean类.
+ 辅助类: `@Autowired`, `@RestController`, `@RestController`, `@PathVariable`, `@RequestMapping`, `@Aspect`, `@Pointcut`.

#### Spring 事务知道吗？有了解过吗？

事务: 满足`ACID`特性.

Spring并不直接管理事务，而是提供了多种事务管理器，他们将事务管理的职责委托给Hibernate或者JTA等持久化机制所提供的相关平台框架的事务来实现。然后在需要进行事务的方法上面添加`@Transactional`即可. 如果是SpringBoot需要在`Application`中添加`@EnableTransactionManagement`.

#### 说下你刚才说的 SpringBoot 吧，你觉得 SpringBoot 有什么优点？

+ 独立运行Spring项目, 以前必须放在web容器中, 这里只需要使用`java -jar xx.jar`运行即可.
+ 内置Servlet容器, 不需要类似`war`来运行.
+ 提供一系列的`starter`工具模块, 促进一站式开发.
+ 极大地减少了配置文件, 提高了开发效率.

+ 1、快速构建项目。
+ 2、对主流开发框架的无配置集成。
+ 3、项目可独立运行，无须外部依赖Servlet容器。
+ 4、提供运行时的应用监控。
+ 5、极大的提高了开发、部署效率。
+ 6、与云计算的天然集成。

#### SpringBoot 自动化配置是怎么做的？有看过实现源码吗？

+ @SpringBootApplication -> @EnableAutoConfiguration
+ @EnableAutoConfiguration -> @Import(AutoConfigurationImportSelector.class)
+ @Import(AutoConfigurationImportSelector.class)则加载Spring默认的自动配置类, 配置类的读取路径是: META-INF下/spring.factories.

#### Spring Boot 中最核心的注解 SpringBootApplication 有看过源码分析过吗？

```java
@Target(ElementType.TYPE)   //用于类,接口,枚举类型
@Retention(RetentionPolicy.RUNTIME) //保存到运行期
@Documented //会被javadoc处理
@Inherited  //该注释会被子类继承
@SpringBootConfiguration
@EnableAutoConfiguration
@ComponentScan(excludeFilters = {
		@Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),
		@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })
```

#### 你的项目中 SpringBoot 用到了哪些和其他技术栈整合的？

+ redis
+ jpa
+ SQL Server
+ Swagger-ui
+ druid

#### 使用 Spring 或者 SpringBoot 有遇到过什么印象深刻的问题吗？当时是怎么解决的？

暂无

### 数据库

#### 你的项目使用的是什么数据库？

Mysql + SqlServer

#### 你对数据库了解多少？说下数据库的索引实现和非主键的二级索引

正在继续学习, 数据库的索引实现方式有很多, 常见的就是B树索引(几点不应当为2个, 可以有多个, 方便磁盘遍历).

非主键的二级索引, 一般是指InnoDB中的索引规则. 在InnoDB中主键索引和别的索引类似, 就是使用B+树来存储数据的行号, 但是二级索引中的B+树存储的不是行号, 而是主键索引中的主键.

#### 说下 MySQL 的索引原理

索引是为了在大数据量下数据查询提供一种快速便捷的方式, 对于重复检索的或者重要的值建立索引表, 下次检索时只需要检索这个索引表来获取对应的位置,进行查找, 可以极快地查找到对象.

常见的索引有: B-Tree索引, B+Tree索引, 哈希索引(类似HashMap实现方式),空间数据索引和全文索引等.

通过索引可以减少服务器需要扫描的数据量, 减少服务器进行排序和临时表, 将随机IO转化为顺序IO.

#### 讲下 InnoDB 和 MyISAM 的区别？使用场景是？

InnoDB: Mysql默认的事务型引擎, 最重要, 使用最广泛的存储引擎. 现由Oracle公司负责开发. InnoDB数据存储在表空间中, 表空间是InnoDB管理的一个黑盒子, 由一系列文件组成.采用MVCC来支持高并发, 并实现了四个标准的隔离级别. 默认隔离级别为: REPEATABLE READ, 并通过间隙锁来防止幻读的出现. 其中InnoDB的表示基于聚族索引建立.

MYISAM: MySQL5.1之前的默认存储引擎, 非事务引擎. 会将表存储在两个文件中, 数据文件MYD和索引文件MDI. MYISAM可以对表进行压缩, 设计简单, 某些场景下性能较好.

需要支持事务的话: InnoDB. 需要在线热备份的话: InnoDB. 如果数据量很大, 系统崩溃之后快速恢复: InnoDB.  不考虑这些问题的话, 如果对于读多写少的情况, MYISAM可以当选, 可以解决很大空间.

#### 有和 ElasticSearch 的索引原理对比过吗？

暂时没有.

#### 如何判断一个查询 sql 语句是否使用了索引？

explain + SQL语句, 就可以看出这个语句执行情况.

#### 数据库事务特性和隔离级别

ACID.

READ UNCOMMITED.

READ COMMITED.

REPETEABLE READ.

SERIEALIZATION

#### 项目数据库表是你设计的吗？一般要注意什么？如何考虑扩展性？

一般是, 注意表结构设计, 尽量简单, 数据范围尽可能小, 避免多个null值, 表与表之间关系清楚. 合理的选择存储引擎和建立索引(其中多列索引的次序也是非常重要的).

拓展性, 添加`version` + `ext`. 是在不行就需要分表存储.

#### 项目 MySQL 的数据量和并发量有多大？量大后的影响有哪些，有考虑吗？SQL 调优有哪些技巧？

单表存储数据1W+, 并发量高峰达到50/s. 就是查询的效率会变低, 时间更长. 建立合理的索引, 必要时进行分表存储.

#### 说下你项目里面关于数据库印象最深的一个问题？当时是怎么解决的

暂无. 

### 其他

#### 描述下网页一个 Http 请求，到后端的整个请求过程

+ DNS解析(浏览器本身缓存 -> 操作系统缓存 -> Hosts规则 -> 域名服务器查询) 域名 -> IP地址
+ 建立TCP连接(三次握手)
+ 发起HTTP请求(报文头部 + 换行(CR + LF) + 报文主体)
+ 解析响应结果.(同上)
+ 浏览器解析HTML(构建DOM树, 下载JS/CSS文件, 构建渲染树)
+ 浏览器布局渲染(布局,绘制)

三次握手:

A -> SYN = 1, SEQ = X -> B : 这个让B知道了B可以正常接收
B -> ACK = X + 1, SEQ = Y -> A : 让A知道了A可以正常发送和可以正常接收
A -> ACK = Y + 1 -> B : 这个让B知道了B也可以正常发送.

四次握手:

A -> FIN = 1, SEQ = X -> B: A告诉B没有要发送的信息了.
B -> ACK = X + 1 -> A: B告诉A我知道了.
B -> FIN = 1, SEQ = Y -> A: B告诉A没有信息要发送了
A -> ACK = Y + 1 -> B : A告诉B我知道了.

#### 有比较过 Http 和 RPC 吗？如果叫你设计一个高性能的 Http 或者 RPC，你会从哪些方面考虑？

#### 项目中我看使用了 xxx （ElasticSearch、Hbase、Redis、Flink 等），有深入了解它们的原理和懂点调优技巧吗？

#### 项目中我看使用了 xxx （ElasticSearch、Hbase、Redis、Mysql 等），有深入了解它们数据同步是怎么做吗？

#### 项目中我看使用了 xxx （ElasticSearch、Hbase、Redis、Mysql 等），有深入了解它们常见的监控指标吗？

#### 如果叫你设计一个秒杀系统，你会从哪些方面考虑？

#### 如果叫你设计一个电商系统，你会从哪些方面考虑？

#### 如果叫你设计一个监控告警系统，你会从哪些方面考虑？

### 招银网络科技面试

## 笔试

### 结果

通过

### 收获

+ 笔试方面比较复杂: 代码, 算法, 数据库等
+ SQL方面知识需要加强

### 面试准备

#### 个人介绍

大家好，我叫蔡剑勇，毕业于西南大学软件工程专业. 个人性格外向偏理性，容易相处，喜欢学习新事物，挑战自己。平时喜欢看书和健身. 在工作之余,会在个人网站上面更新自己的技术博客, 在开源社区和他人讨论技术问题.

#### 面试准备

JVM垃圾回收算法

+ 线程私有: 程序计数器(存储当前方法执行的位置) + 虚拟机栈(每创建一个线程就会携带一个虚拟机栈, 用于执行方法(栈帧(方法名称,方法类等)), 后入先出) + 本地方法栈(用于非Java方法, Native方法,类似虚拟机栈)
+ 线程共有: 方法区(存储类结构相关信息: 常量,静态变量,构造函数等) + 堆(存储Java实例)(年轻代(2Sur(from - to) + 1Eden) + 老年代)
+ 每个实例对象初始化的时候, 默认在Eden分配, 每次MinorGC时, 将Eden区实例对象移动到to区内, from区对象检查年龄, 如果超过一定的大小移动到老年代, 没有超过移动到to区.这时候将from和to身份互换.

+ JVM垃圾回收算法主要是针对堆(Java内存结构: 线程)进行的: 分为Minor GC和FULL GC两种.
+ 标记-清除算法: 先标记, 后统一清除.
+ 复制算法: 分两半, 每次用一半, 拷贝存活到另一端.
+ 标记-整理: 先标记, 后整理.
+ 分代收集算法: 年轻代(Eden + 2Sur) + 老年代.

垃圾收集器:

年轻代:

+ Serial收集器: 串行化(单线程) + Stop the world(适合客户端内存不大)
+ ParNew收集器: Serial收集器的多线程版本.
+ Parallel Scavenge收集器: 复制算法 + 多线程 + 以吞吐量为目标(运行用户代码时间百分比)

老年代:

+ Serial Old收集器: 单线程 + 标记整理算法
+ Parallel Old收集器: 配合Parallel Scanvenge收集器 + 多线程 + 标记整理 + 以吞吐量为目标
+ CMS收集器: 最短停顿时间为目标 + 3次标记1次清除(1,3次标记Stop The World, 2次并发标记) + 标记清除

共用G1收集器:

+ 并行与并发: GI可以充分利用多CPU, 多核环境下的硬件优势, 使用多个CPU来缩短Stop-The-World的停顿时间, 部分其他收集器原本需要停顿Java线程执行的GC动作, G1收集器仍然可以通过并发的方式让Java程序继续执行.
+ 分代收集: 与其他收集器一样, 分代的概念在G1中依然可以保留. 虽然G1可以不需要其他收集器配合就能独立管理整个GC堆, 但它能够采用不同的方式去处理新创建的对象和已经存活了一段时间, 熬过了多次GC的旧对象以获得更好的收集效果.
+ 空间整合: 与CMS的标记-清理算法不同, G1从整体来看是基于标记-整理算法实现的收集器, 从局部(两个Region之间)上来看是基于复制算法实现的, 但无论如何, 这两种算法都意味着G1运行区间不会产生内存空间碎片.
+ 可预测的停顿: 这是G1相对CMS的另一大优势,降低停顿时间是G1和CMS共同的关注点, 但G1除了追求低停顿外, 还能建立可预测的停顿时间模型, 可以让使用者明确指定在一个长度为M毫秒的时间片段内, 消耗垃圾收集上的时间不得超过N毫秒, 这几乎已经是实时Java(RTSJ)的垃圾收集器的特征了.

Mysql的索引:

+ B树: 就是一种特殊的二叉树, 它的子节点不一定只有两个.
+ 一棵m阶的B树满足树中每个结点至多有m个子节点。除根结点和叶子结点外，其它每个结点至少有m/2个子节点。这样做的一个好处就是限制住了树的高度, 防止造成磁盘I/O读写过于频繁，进而导致查询效率低下.
+ B+树: 优化了B树, 不在把数据存储在非叶节点, 所有的数据都存储在叶节点, 非页节点只起到了辅助定位的作用. 然后每个叶节点块通过指针连接, 收尾相连, 保证了读取时连续性.
+ Hash索引: 实现方式类似HashMap. 计算哈希值, 然后放入到对应的桶里面. 数据非常紧凑, 查询效率非常高. 适合索引对象非常大的情况. InnoDB存储引擎中还实现了自适应哈希索: 就是在B树的基础上, 创建临时的哈希索引, 这样即拥有B树的存储优势, 也具有哈希值快速查找的结果.
+ InnoDB的聚族索引: 是指非主键索引存储的主键索引, 而主键索引存储的才是行号.

Spring IOC和AOP:

`IOC`: Inversion of Control, 当某个角色需要另外一个角色协助的时候，在传统的程序设计过程中，通常由调用者来创建被调用者的实例。但在spring中创建被调用者的工作不再由调用者来完成，因此称为控制反转。创建被调用者的工作由spring来完成，然后注入调用者. 因此也称为依赖注入。spring以动态灵活的方式来管理对象 ， 注入的两种方式，设置注入和构造注入。 设置注入的优点：直观，自然. 构造注入的优点：可以在构造器中决定依赖关系的顺序.

`AOP`: 面向对象编程将程序分解成各个层次的对象，面向切面编程将程序运行过程分解成各个切面。面向切面编程，通过`预编译方式`和`运行期动态代理(Java代理,Cglib)`生成代理类来实现程序功能的统一维护的一种技术。在不影响原来功能代码的基础上，使用动态代理加入自己需要的一些功能（比如权限的验证，事务的控制，日志的记录等等），移除之后，并不影响原来的功能. 底层通过`ASM`实现, Java代理, 通过让代理类和原来类都实现同一个接口. Cglib: 让代理类继承原来类. 都可以保证不侵染代码, 保证代码的纯洁性. 一般通过注解和xml注释来实现.

java多态的内存实现方式，内存中是如何调用子类的方法？

+ 每个栈帧中持有局部变量表, 操作数栈, 动态链接, 方法返回地址, 附加信息等. 而动态链接中存储着这个信息: 每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用, 持有这个引用是为了支持方法调用过程中的动态链接(Dynamic Linking). 在字节码中的方法包含了指向常量池中的方法符号引用, 这部分的符号引用有一部分会在类加载阶段或者第一次使用时候就转化为直接引用, 这种转化成为静态解析. 另一部分将在每一次运行区间转化为直接引用, 这部分称为动态链接. 而多态就是通过JVM虚拟机中的方法指令(`invokevirtual`)实现的.invokervirtual第一步就是在运行期确定接收者的实际类型, 所以invokervirtual指令把常量池中的类方法符号引用解析到了不同的直接引用实现上了. 这就是重写的本质. 从当前实现类的内部从下到上的方式查找方法(如果本类不存在, 就去父类查找).

父类声明对象和子类初始化，两者在内存中的位置？

+ 父类static修饰的模块 ->子类static修饰模块
+ 父类实例变量和非static块 - 父类对应构造函数。当子类对应构造函数中没有显示调用时调用的是父类默认的构造函数。
+ 子类实例变量和非static块 -> 子类构造函数

使用类加载器加载父类相关信息, 将类信息和常量存放到方法区中, 然后加载子类的信息和常量放置到方法区中, 在堆中创建子类的实例对象, 然后在栈帧中创建父类的引用指向堆中的子类实例.

jvm内存模型中老年代满了，继续往里添加会怎样？

+ 会触发FULL GC. 这时候JVM会强制进行垃圾回收.

传统分布式系统与微服务的区别？

传统的分布式是指将一个大的系统划分为不同的业务模块, 将不同的业务模块部署到不同的服务器上.
而微服务则是侧重的是将一个大的功能安装不同的模块进行划分, 进行分别部署, 相同的功能模块可以部署多个, 也可以部署在同一个服务器, 提供更高的弹性.

类似, 也是有区别, 传统的分布式侧重的是分散业务压力, 而微服务则是提供一种高弹性和安全性的划分.

微服务的技术点有哪些？用户同时用到几个微服务，那么如何保证用户状态？

+ 服务路由: 所有的服务只提供单个入口点, 便于将安全策略和日志管理应用到所有的服务和服务实例中.
+ 服务发现: 通过动态获取服务列表, 进行动态访问, 防止硬编码, 便于服务列表管理.
+ 提供微服务的弹性: 客户端负载均衡, 断路器模式, 后备模式, 舱壁模式. 优雅降级.

+ 可以在ZUUL统一路由的接口添加一个Filter, 在一个请求进入的时候, 设置一个HTTP头信息, 如`trasaction_id`. 然后在每一个微服务里面记录对应的`trasaction_id`, 调用其它微服务时就可以传递该信息(在调用时添加Filter, 动态添加该信息).

二维码扫描登录的处理过程？

首先网页端向后台发送请求, 生成一个带token新的二维码, 后台存储对应的token信息, 然后网页端一直采用轮询的方式向后台查询对应的信息. 手机端通过通过扫描二维码, 传递token信息和用户信息, 后台校验成功后, 给网页端成功标识, 顺利登陆.

后台登录的安全机制有哪些？

OAUTH2

hashMap和hashtable的区别

+ hashMap: 线程不安全的, 数组 + 链表, 链表个数超过7个转化为红黑树
+ hashtable: 线程安全的, 数组 + 链表, 读取和写入都需要获取对象锁.

String StringBuffer和StringBuilder的区别

+ String 不变类, StringBuilder可变类, StringBuffer线程安全的.

还有一些框架，还有数据库的事务，数据库的索引的优缺点，数据库的范式

ACID.

READ UNCOMMITED.

READ COMMITED.

REPETEABLE READ.

SERIEALIZATION

第一范式：当关系模式R的所有属性都不能在分解为更基本的数据单位时，称R是满足第一范式的，简记为1NF。满足第一范式是关系模式规范化的最低要

求，否则，将有很多基本操作在这样的关系模式中实现不了。

第二范式：如果关系模式R满足第一范式，并且R得所有非主属性都完全依赖于R的每一个候选关键属性，称R满足第二范式，简记为2NF。

第三范式：设R是一个满足第一范式条件的关系模式，X是R的任意属性集，如果X非传递依赖于R的任意一个候选关键字，称R满足第三范式，简记为3NF.

问spring使用的设计模式

+ 单例模式, Spring内部的Bean默认都是单例的
+ 工厂模式, factory-method, 指定工厂生成方法.
+ 适配器/装饰者模式: 有很多Adapter接口, 默认实现了很多功能.
+ 代理: 通过动态生成代理类, 实现AOP.
+ 模板方法: JDBCTemplate

二面：全程怼项目，随时打断问问题，这个没有太大的参考价值。

树的非递归遍历，还有java的一些基本知识，例如string stringBuilder stringBuffer的区别，

谈的是项目经验，感觉不是很好

TCP/IP中长短连接是用来干什么的。
答短连接在请求完资源后就可以释放，用来防止长期占用服务器资源。长连接用于保持连接，防止多次建立连接浪费资源，有一种DDOS攻击就利用了长连接。

jvm相关，为何xmx和xms设成一样如何自己实现注解classloader流程spring如何初始化类bean，ioc原理自己写socket，不会线程安全实现存取款类，写代码写socket。

mys数据库事务的隔离级别以及mysql的默认隔离级别。

JVMJava程序的特征，如何实现多态多线程索引，索引分类；二面：项目介绍；三面：HR

自我介绍；2. 项目；3. 介绍一下JVM, 说了内存分区和垃圾回收；4. 创建线程的方式，你一般用哪种，为什么？5. 设计模式，用过哪些。特别问了观察者模式；6. 用过哪些框架，springMVC 核心，答了Ioc和AOP。

你对哪方面比较熟悉？2.Java面向对象的特点（详细说明）3.Java可以继承多个类吗？4.说一下类里的Static？5.静态代码块和构造器代码的不同？6.说一下设计模式的原则？比如说开闭原则？7.说一下单例模式。

你知道几种排序算法？

答堆排序，归并排序，快速排序。

1. stack 和 heap有什么区别；2. sql语句说明怎么实现选出第二高的成绩；3. jvm简要说一下；4. GDBC用过吗，介绍一下。这个楼主答没用过，面试官无奈的说下一个。5. tcp了解吗？三次握手四次挥手什么意思？6. 聊了聊项目；最后问了楼主一个女孩子为什么要做java开发。

数据库什么时候用到索引

HTTP和HTTPS什么区别？HTTPS使用了哪些加密机制？如何缩短HTTPS访问服务器的时间？

答HTTPS比HTTP安全，HTTPS采用的几种加密算法可以从网上找到。至于缩短访问时间就主要从几次挥手上来缩短了。可以看看《HTTP权威指南》深入了解。

答就是把自己做过的讲出来，用到哪些技术，遇到哪些难题，如何解决的，说清楚。还有你负责哪些部分等

单链表和双链表的几种操作

答插入、删除、查找还有算法复杂度

tomcat
网络重定向，说下流程
http协议
servlet是单例么？
多线程共享变量的问题？
java 几种修饰符 的区别
一个web服务，如何搭建环境。

java代码是怎么运行的。
答我是结合类的加载过程和内存模型回答的，感觉回答的有点乱。
问数据库的翻页怎么操作。
答当时忘了这个答案
问servlet的生命周期
答这个相对容易些
问spring使用的设计模式
答只回答了工厂模式和单利模式，回答的不好