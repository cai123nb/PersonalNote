# ç®—æ³•å°è®°

ç®—æ³•ç›¸å…³ç¬”è®°å’Œç»å…¸é¢˜ç›®.

## å°æŠ€å·§

### ä¿¡æ¯å¤ç”¨

å¦‚æœå‘ç°å½“å‰ç®—æ³•, æ¯æ¬¡è¿­ä»£ä¸­é‡å¤ä½¿ç”¨(æˆ–è€…è®¡ç®—è·å–)æ–°çš„ä¿¡æ¯, é‚£ä¹ˆä¹Ÿå°±æ„å‘³ç€ç®—æ³•å¯ä»¥è¿›è¡Œä¼˜åŒ–, ä½¿ç”¨æŸç§æ•°æ®ç»“æ„(æ•°ç»„æˆ–è€…è‡ªå®šä¹‰)å­˜å‚¨å¤ç”¨çš„ä¿¡æ¯, è¿›è¡Œç®—æ³•çš„ä¼˜åŒ–.

### é¡ºåºç›¸å…³

å¯¹äºæŸäº›è®¡ç®—æ˜¯å’Œé¡ºåºç›¸å…³æ—¶, ä¸€èˆ¬çš„æ’åºæ˜¯ä¼šæ‰“ä¹±é¡ºåºçš„, è¿™æ—¶å€™å¯ä»¥è€ƒè™‘ä½¿ç”¨ç›®æ ‡åºåˆ—æ“ä½œ: `group[n] = a[1] + a[2] + ... + a[n]`. è¿™é‡Œä»¥åŠ æ³•ä¸ºä¾‹, è¿™æ ·å°±å¯ä»¥å½¢æˆä¸€ä¸ªèšåˆæ•°ç»„`[group[0], group[1], ... , group[n]]`. è¿™ç§æ•°ç»„åœ¨è¿›è¡Œé¡ºåºè®¡ç®—æ—¶å¾€å¾€æ›´åŠ æ–¹ä¾¿.

## æœ‰è¶£çš„ç®—æ³•é¢˜

### 1.Special Palindrome Again

[åŸæ–‡ link](https://www.hackerrank.com/challenges/special-palindrome-again/problem)

#### 1.1.Description

A string is said to be a `special palindromic` string if either of two conditions is met:

- All of the characters are the same, e.g. `aaa`.
- All characters except the middle one are the same, e.g. `aadaa`.

A special palindromic substring is any substring of a string which meets one of those criteria. Given a string, determine how many special palindromic substrings can be formed from it.

For example, given the string `s = mnonopoo`, we have the following special palindromic substrings: `{m, n, o, n, o, p, o, o, non, ono, opo, oo}`.

##### 1.1.1.Function Description

Complete the substrCount function in the editor below. It should return an integer representing the number of special palindromic substrings that can be formed from the given string.

substrCount has the following parameter(s):

- `n`: an integer, the length of string s.
- `s`: a string

##### 1.1.2.Input Format

The first line contains an integer, `n` , the length of `s`.
The second line contains the string `s`.

##### 1.1.3.Constraints

- `1 <= n <= 10^6`
- Each character of the string is a lowercase alphabet, `ascii[a-z]`.

##### 1.1.4.Output Format

Print a single line containing the count of total special palindromic substrings.

#### 1.2.Sample

##### 1.2.1.Sample Input

```java
5
asasd
```

##### 1.2.2.Sample Output

```java
7
```

##### 1.2.3.Explanation

The special palindromic substrings of `s=asasd` are `{a, s, a, s, d, asa, sas}`.

#### 1.3.Thinking space

1s

2s

3s

4s

5s

6s

7s

8s

9s

10s

#### 1.4.Solution

```java
//Record char frequency struct
static class Point {
    public char key;
    public long count;

    public Point(char x, long y) {
        key = x;
        count = y;
    }
}

// Complete the substrCount function below.
static long substrCount(int n, String s) {
    s = s + " ";
    ArrayList<Point> l = new ArrayList<Point>();
    long count = 1;
    char ch = s.charAt(0);
    //Record all char frequency
    for(int i = 1; i <= n ; i++) {
        if(ch == s.charAt(i))
            count++;
        else {
            l.add(new Point(ch, count));
            count = 1;
            ch = s.charAt(i);
        }
    }
    count = 0;
    //If size >= 3, it may combine aabaa type
    if(l.size() >= 3) {
        Iterator<Point> itr = l.iterator();
        Point prev, curr, next;
        curr = (Point)itr.next();
        next = (Point)itr.next();
        count = (curr.count * (curr.count + 1)) / 2;
        for(int i = 1; i < l.size() - 1; i++) {
            prev = curr;
            curr = next;
            next = itr.next();
            count += (curr.count * (curr.count + 1)) / 2;
            //if chars can combile like: aaaxaaa, record counts
            if(prev.key == next.key && curr.count == 1)
                count += prev.count > next.count ? next.count : prev.count;
        }
        count += (next.count * (next.count + 1)) / 2;
    } else {
        //Just record equals situations
        for(Point curr:l){
            count += (curr.count * (curr.count + 1)) / 2;
        }
    }
    return count;
}
```

### 2.Common Child

[åŸæ–‡ link](https://www.hackerrank.com/challenges/common-child/problem)

#### 2.1.Description

A string is said to be a child of a another string if it can be formed by deleting 0 or more characters from the other string. Given two strings of equal length, what's the longest string that can be constructed such that it is a child of both?

For example, `ABCD` and `ABDC` have two children with maximum length 3, `ABC` and `ABD`. They can be formed by eliminating either the `D` or `C` from both strings. Note that we will not consider `ABCD` as a common child because we can't rearrange characters and `ABCD`, `ABDC`.

##### 2.1.1.Function Description

Complete the commonChild function in the editor below. It should return the longest string which is a common child of the input strings.

commonChild has the following parameter(s):

- `s1, s2`: two equal length strings

##### 2.1.2.Input Format

There is one line with two space-separated strings, `s1` and `s2`.

##### 2.1.3.Constraints

- `1 <= s1, s2 <= 5000`.
- All characters are upper case in the range ascii[A-Z].

##### 2.1.4.Output Format

Print the length of the longest string , such that is a child of both `s1` and `s2`.

#### 2.2.Sample

##### 2.2.1.Sample Input

```java
HARRY
SALLY
```

##### 2.2.2.Sample Output

```java
2
```

##### 2.2.3.Explanation

The longest string that can be formed by deleting zero or more characters from `HAPPY` and `SALLY` is `AY`, whose length is 2.

#### 2.3.Thinking space

1s

2s

3s

4s

5s

6s

7s

8s

9s

10s

#### 2.4.Solution

```java
    // Complete the commonChild function below.
    static int commonChild(String s1, String s2) {
        //https://en.wikipedia.org/wiki/Longest_common_subsequence_problem
        //Assume s1 char array is [X1, X2, X3, ... , Xn]
        //Assume s2 char array is [Y1, Y2, Y3, ... , Ym]
        /*
                        if (n = 0 || m = 0) return "";
        LCS(Xn, Ym) =   else if (Xn = Xm) return LCS(Xn-1, Ym-1) + Xn;
                        else return Math.max(LCS(Xn-1, Ym), LCS(Xn, Ym-1));
        */
        // Assume s1=AGCAT, S2=GAC
        //    ""    A       G       C       A       T
        // "" ""    ""      ""      ""      ""      ""
        // G  ""    ""      G       G       G       G
        // A  ""    A      A|G      A|G     GA      GA
        // C  ""    A      A|G      AC|GC  AC|GC|GA AC|GC|GA

        char[] charsA = s1.toCharArray(), charsB = s2.toCharArray();
        int[][] datas = new int[charsA.length + 1][charsB.length + 1];

        for (int i = 0; i < charsA.length; i++) {
            for (int j = 0; j < charsB.length; j++) {
                if (charsA[i] == charsB[j]) {
                    datas[i + 1][j + 1] = 1 + datas[i][j];
                } else {
                    datas[i + 1][j + 1] = Math.max(datas[i][j + 1], datas[i + 1][j]);
                }
            }
        }

        return datas[charsA.length][charsB.length];
    }
```

### 3.Merge Sort: Counting Inversions

[åŸæ–‡ link](https://www.hackerrank.com/challenges/ctci-merge-sort/problem)

#### 3.1.Description

In an array,`arr`, the elements at indices `i` and `j` (where `i < j`) form an inversion if `arr[i] > arr[j]`. In other words, inverted elements `arr[i]` and `arr[j]` are considered to be "out of order". To correct an inversion, we can swap adjacent elements.

For example, consider the dataset `arr = [2,4,1]`. It has two inversions: `(4,1)`and `(2,1)`. To sort the array, we must perform the following two swaps to correct the inversions:

`arr=[2,4,1] -> swap(arr[1], arr[2]) -> swap(arr[0], arr[1]) -> [1,2,4]`

Given `d` datasets, print the number of inversions that must be swapped to sort each dataset on a new line.

##### 3.1.1.Function Description

Complete the function countInversions in the editor below. It must return an integer representing the number of inversions required to sort the array.

countInversions has the following parameter(s):

- `arr`: an array of integers to sort .

##### 3.1.2.Input Format

The first line contains an integer, `d`, the number of datasets.

Each of the next `d` pairs of lines is as follows:

- The first line contains an integer, `n`, the number of elements in `arr`.

- The second line contains `n` space-separated integers, `arr[i]`.

##### 3.1.3.Constraints

- `1 <= d <= 15`

- `1 <= n <= 10^5`

- `1 <= arr[i] <= 10^7`

##### 3.1.4.Output Format

For each of the `d` datasets, return the number of inversions that must be swapped to sort the dataset

#### 3.2.Sample

##### 3.2.1.Sample Input

```java
2
5
1 1 1 2 2
5
2 1 3 1 2
```

##### 3.2.2.Sample Output

```java
0
4
```

##### 3.2.3.Explanation

We sort the following `d = 2` datasets:

- `arr = [1,1,1,2,2]` is already sorted, so there are no inversions for us to correct. Thus, we print `0` on a new line.

- `arr = [2,1,3,1,2] -(1swap)-> [1,2,3,1,2] -(2swap)-> [1,1,2,3,2] -(1swap)-> [1,1,2,2,3]` We performed a total of `1 + 2 + 1 = 4` swaps to correct inversions.

#### 3.3.Thinking space

1s

2s

3s

4s

5s

6s

7s

8s

9s

10s

#### 3.4.Solution

```java
// Complete the countInversions function below.
static long countInversions(int[] arr) {
    long swaps = 0;
    for (int gap = 1; gap < arr.length; gap = 2 * gap) {
        swaps += mergePass(arr, gap, arr.length);     //Merge two gag's length sorted array to a sorted array.
    }
    return swaps;
}

private static long mergePass(int[] array, int gap, int length) {
    long swaps = 0;
    int i = 0;
    for (i = 0; i + 2 * gap - 1 < length; i = i + 2 * gap) {    //Merge two adjacent gap length's datas
        swaps += merge(array, i, i + gap - 1, i + 2 * gap - 1);
    }
    if (i + gap - 1 < length) {
        //If left datas' length is larger than a gap which means
        // the left datas need to sort. else the data is already sorted.
        swaps += merge(array, i, i + gap - 1, length - 1);
    }
    return swaps;
}

private static long merge(int[] array, int low, int mid, int high) {
    long swaps = 0;
    int i = low, j = mid + 1, k = 0;
    int[] array2 = new int[high - low + 1];
    while (i <= mid && j <= high) {  //Merge target number into array2
        if (array[i] <= array[j]) {
            array2[k] = array[i];
            i++;
            k++;
        } else {
            array2[k] = array[j];
            //because adjacent array is sorted, so the right
            //array swaps times max_value will be a gap (mid + 1)
            //If left array choose one to store, swaps times will
            //decrease one
            swaps += mid + 1 - i;
            j++;
            k++;
        }
    }
    while (i <= mid) { //Left array still have some datas.
        array2[k] = array[i];
        i++;
        k++;
    }
    while (j <= high) { //Right array still have some datas.
        array2[k] = array[j];
        j++;
        k++;
    }
    for (k = 0, i = low; i <= high; i++, k++) { //Store result
        array[i] = array2[k];
    }
    return swaps;
}
```

### 4.Array Manipulation

[åŸæ–‡ link](https://www.hackerrank.com/challenges/crush/problem)

#### 4.1.Description

ç»™ä½ ä¸€ä¸ªé•¿åº¦ä¸º N çš„åˆ—è¡¨ï¼Œåˆ—è¡¨çš„åˆå§‹å€¼å…¨æ˜¯ 0ã€‚å¯¹æ­¤åˆ—è¡¨ï¼Œä½ è¦è¿›è¡Œ M æ¬¡æŸ¥è¯¢ï¼Œè¾“å‡ºåˆ—è¡¨ç§æœ€ç»ˆ N ä¸ªå€¼çš„æœ€å¤§å€¼ã€‚å¯¹æ¯æ¬¡æŸ¥è¯¢ï¼Œç»™ä½ çš„æ˜¯ 3 ä¸ªæ•´æ•°â€”â€”a,b å’Œ kï¼Œä½ è¦å¯¹åˆ—è¡¨ä¸­ä»ä½ç½® a åˆ°ä½ç½® b èŒƒå›´å†…çš„ï¼ˆåŒ…å« a å’Œ b)çš„å…¨éƒ¨å…ƒç´ åŠ ä¸Š kã€‚

##### 4.1.1.Input Format

ç¬¬ä¸€è¡ŒåŒ…å«ä¸¤ä¸ªæ•´æ•° N å’Œ Mã€‚
æ¥ä¸‹æ¥ M è¡Œï¼Œæ¯è¡ŒåŒ…å« 3 ä¸ªæ•´æ•° a, b å’Œ kã€‚

##### 4.1.2.Constraints

- `3 <= N <= 10^7`

- `1 <= M <= 2*10^5`

- `1 <= a <= b <= N`

- `0 <= k <= 10^9`

##### 4.1.3.Output Format

å•ç‹¬çš„ä¸€è¡ŒåŒ…å« æœ€ç»ˆåˆ—è¡¨é‡Œçš„æœ€å¤§å€¼.

#### 4.2.Sample

##### 4.2.1.Sample Input

```java
5 3
1 2 100
2 5 100
3 4 10
```

##### 4.2.2.Sample Output

```java
200
```

##### 4.2.3.Explanation

ç¬¬ä¸€æ¬¡æ›´æ–°åï¼Œåˆ—è¡¨å˜ä¸º `100 100 0 0 0`.
ç¬¬äºŒæ¬¡æ›´æ–°åï¼Œåˆ—è¡¨å˜ä¸º `100 200 100 100 100`ã€‚
ç¬¬ä¸‰æ¬¡æ›´æ–°åï¼Œåˆ—è¡¨å˜ä¸º `100 200 200 200 100`ã€‚
å› æ­¤è¦æ±‚çš„ç­”æ¡ˆæ˜¯`200`

#### 4.3.Thinking space

1s

2s

3s

4s

5s

6s

7s

8s

9s

10s

#### 4.4.Solution

```java
private static final Scanner scanner = new Scanner(System.in);

public static void main(String[] args) throws IOException {
    BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv("OUTPUT_PATH")));

    String[] nm = scanner.nextLine().split(" ");

    int n = Integer.parseInt(nm[0]);

    int m = Integer.parseInt(nm[1]);

    //Use datas as number buoy, recoard number change.
    long[] datas = new long[n];

    int[] group = new int[3];

    for (int i = 0; i < m; i++) {
        String[] queriesRowItems = scanner.nextLine().split(" ");
        scanner.skip("(\r\n|[\n\r\u2028\u2029\u0085])?");

        for (int j = 0; j < 3; j++) {
            group[j] = Integer.parseInt(queriesRowItems[j]);
        }
        //From group[0] - grou[1], it will increase nums.
        datas[group[0] - 1] += group[2];
        //Here need to be notice, the range is includeï¼Œ after the range, it will decrease
        if (group[1] < n) {
            datas[group[1]] -= group[2];
        }
    }

    long currentValue = 0;
    long max= Long.MIN_VALUE;
    for (int i = 0; i < n; i++) {
        currentValue += datas[i];
        if (currentValue > max) {
            max = currentValue;
        }
    }

    bufferedWriter.write(String.valueOf(max));
    bufferedWriter.newLine();

    bufferedWriter.close();

    scanner.close();
}
```

### 5.Count Triplet

[åŸæ–‡ link](https://www.hackerrank.com/challenges/count-triplets-1/problem)

#### 5.1.Description

You are given an array and you need to find number of tripets of indices `(i,j,k)` such that the elements at those indices are in geometric progression for a given common ratio `r` and `i < j < k`.

For example, `arr=[1,4,16,64]`. If `r=4`, we have `[1,4,16]` and `[4,16,64]` at indices `(0,1,2)`and`(1,2,3)` .

##### 5.1.1.Function Description

Complete the countTriplets function in the editor below. It should return the number of triplets forming a geometric progression for a given `r` as an integer.

countTriplets has the following parameter(s):

- `arr`: an array of integers.

- `r`: an integer, the common ratio.

##### 5.1.2.Input Format

The first line contains two space-separated integers `n` and `r`, the size of `arr` and the common ratio.
The next line contains `n` space-seperated integers `arr[i]` .

##### 5.1.3.Constraints

- `1 <= n <= 10^5`

- `1 <= r <= 10^9`

- `1 <= arr[i] <= 10^9`

##### 5.1.4.Output Format

Return the count of triplets that form a geometric progression.

#### 5.2.Sample

##### 5.2.1.Sample Input

```java
4 2
1 2 2 4
```

##### 5.2.2.Sample Output

```java
2
```

##### 5.2.3.Explanation

There are 2 triplets in satisfying our criteria, whose indices are `(0,1,3)` and `(0,2,3)`.

#### 5.3.Thinking space

1s

2s

3s

4s

5s

6s

7s

8s

9s

10s

#### 5.4.Solution

```java
// Complete the countTriplets function below.
static long countTriplets(List<Long> arr, long r) {
    //Conside the triple is A, B, C (B = A * r, C = A * r * r = B * r)
    //B demand counts, if an long input will increase B(A * r)demand
    Map<Long, Long> t2 = new HashMap<>();
    //C deamnd counts, if an long input will statisfy C demand,
    //will combine a triple
    Map<Long, Long> t3 = new HashMap<>();
    long result = 0L;

    for(Long a : arr) {
        //If long a can fit C demand, it will combine some triples.
        result += t3.getOrDefault(a, 0L);
        if (t2.containsKey(a)){
            //If long a can fit B demand, will increase C demand.
            t3.put(a*r, t3.getOrDefault(a*r, 0L) + t2.get(a));
        }
        //every a can be A, will increase B demand.
        t2.put(a*r, t2.getOrDefault(a*r, 0L) + 1);
    }
    return result;
}
```

### 6.Special Palindrome Again

[åŸæ–‡ link](https://www.hackerrank.com/challenges/special-palindrome-again/problem)

#### 6.1.Description

A string is said to be a `special palindromic` string if either of two conditions is met:

- All of the characters are the same, e.g. `aaa`.

- All characters except the middle one are the same, e.g. `aadaa`.

A special palindromic substring is any substring of a string which meets one of those criteria. Given a string, determine how many special palindromic substrings can be formed from it.

For example, given the string `s = mnonopoo`, we have the following special palindromic substrings: `{m, n, o, n, o, p, o, o, non, ono, opo, oo}`.

##### 6.1.1.Function Description

Complete the substrCount function in the editor below. It should return an integer representing the number of special palindromic substrings that can be formed from the given string.

substrCount has the following parameter(s):

- `n`: an integer, the length of string s

- `s`: a string

##### 6.1.2.Input Format

The first line contains an integer, `n` , the length of `s`.
The second line contains the string `s`.

##### 6.1.3.Constraints

- `1 <= n <= 10^6`

- Each character of the string is a lowercase alphabet, `ascii[a-z]`.

##### 6.1.4.Output Format

Print a single line containing the count of total special palindromic substrings.

#### 6.2.Sample

##### 6.2.1.Sample Input

```java
5
asasd
```

##### 6.2.2.Sample Output

```java
7
```

##### 6.2.3.Explanation

The special palindromic substrings of `s=asasd` are `{a, s, a, s, d, asa, sas}`.

#### 6.3.Thinking space

1s

2s

3s

4s

5s

6s

7s

8s

9s

10s

#### 6.4.Solution

```java
//Record char frequency struct
static class Point {
    public char key;
    public long count;

    public Point(char x, long y) {
        key = x;
        count = y;
    }
}

// Complete the substrCount function below.
static long substrCount(int n, String s) {
    s = s + " ";
    ArrayList<Point> l = new ArrayList<Point>();
    long count = 1;
    char ch = s.charAt(0);
    //Record all char frequency
    for(int i = 1; i <= n ; i++) {
        if(ch == s.charAt(i))
            count++;
        else {
            l.add(new Point(ch, count));
            count = 1;
            ch = s.charAt(i);
        }
    }
    count = 0;
    //If size >= 3, it may combine aabaa type
    if(l.size() >= 3) {
        Iterator<Point> itr = l.iterator();
        Point prev, curr, next;
        curr = (Point)itr.next();
        next = (Point)itr.next();
        count = (curr.count * (curr.count + 1)) / 2;
        for(int i = 1; i < l.size() - 1; i++) {
            prev = curr;
            curr = next;
            next = itr.next();
            count += (curr.count * (curr.count + 1)) / 2;
            //if chars can combile like: aaaxaaa, record counts
            if(prev.key == next.key && curr.count == 1)
                count += prev.count > next.count ? next.count : prev.count;
        }
        count += (next.count * (next.count + 1)) / 2;
    } else {
        //Just record equals situations
        for(Point curr:l){
            count += (curr.count * (curr.count + 1)) / 2;
        }
    }
    return count;
}
```

### 7.Reverse Shuffle Merge

[åŸæ–‡ link](https://www.hackerrank.com/challenges/reverse-shuffle-merge/problem)

#### 7.1.Description

Given a string, `A`, we define some operations on the string as follows:

- `reverse(A)` denotes the string obtained by reversing string `A`. Example: `reverse("abc") = "cba"`
- `shuffle(A)` denotes any string that's a permutation of string `A`. Example: `shuffle("god") = {"god", "gdo", "ogd", "odg", "dog", "dgo"}`
- `merge(A1,A2)` denotes any string that's obtained by interspersing the two strings `A1` & `A2`, maintaining the order of characters in both. For example, `A1 = "abc"` & `A2 = "def"`, one possible result of `merge(A1,A2)` could be `abcdef`, another could be `abdecf`, another could be `adbecf` and so on.

Given a string `s` such that `s = merge(reverse(A), shuffle(A))` for some string `A`, find the lexicographically smallest `A`.

For example, `s=abab`. We can split it into two strings of `ab`. The reverse is `ba` and we need to find a string to shuffle in to get `abab`. The middle two characters match our reverse string, leaving the `a` and `b` at the ends. Our shuffle string needs to be `ab`. Lexicographically `ab < ba`, so our answer is `ab`.

##### 7.1.1.Function Description

Complete the reverseShuffleMerge function in the editor below. It must return the lexicographically smallest string fitting the criteria.

reverseShuffleMerge has the following parameter(s):

- `s` : a string

##### 7.1.2.Input Format

A single line containing the string `s`.

##### 7.1.3.Constraints

- `s` contains only lower-case English letters, ascii[a-z]
- `1 <= |s| <= 10000`

##### 7.1.4.Output Format

Find and return the string which is the lexicographically smallest valid `A`.

#### 7.2.Sample

##### 7.2.1.Sample Input

```java
abcdefgabcdefg
```

##### 7.2.2.Sample Output

```java
agfedcb
```

##### 7.2.3.Explanation

Split the string into two strings with like characters: `abcdefg` and `abcdefg`.

Reverse `agfedcb` = `bcdefga`

Shuffle `agfedcb` can be `abcdefg`.

Merge to `a**bcdefga**bcdefg`.

#### 7.3.Thinking space

1s

2s

3s

4s

5s

6s

7s

8s

9s

10s

#### 7.4.Solution

```java
//LeftChars store all chars in the string, neededChars store result chars.
private static int[] leftChars = new int[26], neededChars = new int[26];
//Every time when we search best char, we store skipped chars in here.
private static int[] skippedChars;


static String reverseShuffleMerge(String s) {
    // forget about reverse - now merge is done on original string and its shuffle
    s = new StringBuilder(s).reverse().toString();

    //Store result in StringBuilder.
    StringBuilder sb = new StringBuilder();
    //Read all char to leftChars.
    createLeftChars(s);
    //We just need half of all chars.
    createNeededChars();

    //Auxiliary variable, lastIndex store each loop start index
    int lastIndex = -1;
    int currentIndex;
    char currentChar;
    int bestIndex;
    char bestChar;

    //Each loop, we search the smallest char for result's elements.
    while (sb.length() < s.length() / 2) {
        //26 english alphabet.
        skippedChars = new int[26];

        currentIndex = lastIndex + 1;
        bestIndex = lastIndex;
        bestChar = '{';

        do {
            currentChar = s.charAt(currentIndex);
            //If we need it and it's less than bestChar
            if (neededChars[currentChar - 'a'] > 0 && currentChar < bestChar) {
                bestChar = currentChar;
                bestIndex = currentIndex;
            }
            skipChar(currentChar);
            currentIndex++;
        } while(canBeSkipped(currentChar));

        sb.append(bestChar);
        //Remove elements before best char, because the sb is sequential
        //These elements before best char, are unreachable.
        for (int i = lastIndex + 1; i <= bestIndex; i++) {
            leftChars[s.charAt(i) - 'a']--;
        }
        neededChars[bestChar - 'a']--;
        lastIndex = bestIndex;
    }
    return sb.toString();
}

private static void createLeftChars(String s) {
    for (int i = 0; i < s.length(); i++) {
        char currentChar = s.charAt(i);
        leftChars[currentChar - 'a']++;
    }
}

private static void createNeededChars() {
    for (int i = 0; i < 26; i++) {
        neededChars[i] = leftChars[i] / 2;
    }
}

private static void skipChar(char currentChar) {
    skippedChars[currentChar - 'a']++;
}

private static boolean canBeSkipped(char currentChar) {
    int position = currentChar - 'a';
    return (leftChars[position] - skippedChars[position] - neededChars[position]) >= 0;
}
```

### 8.Maximum Subarray Sum

[åŸæ–‡ link](https://www.hackerrank.com/challenges/maximum-subarray-sum/problem)

#### 8.1.Description

ç»™ä½ ä¸€ä¸ªå¤§å°ä¸º N çš„æ•°ç»„å’Œå¦å¤–ä¸€ä¸ªæ•´æ•° Mã€‚ä½ çš„ç›®æ ‡æ˜¯æ‰¾åˆ°æ¯ä¸ªå­æ•°ç»„çš„å’Œå¯¹ M å–ä½™æ•°çš„æœ€å¤§å€¼ã€‚

å­æ•°ç»„æ˜¯æŒ‡åŸæ•°ç»„çš„ä»»æ„è¿ç»­å…ƒç´ çš„å­é›†ã€‚

æ³¨æ„ä½ éœ€è¦æ‰¾åˆ° max(å­æ•°ç»„çš„å’Œï¼‰%M ï¼Œå…¶ä¸­ä¸€å…±æœ‰`N*(N + 1)/2`ä¸ªå¯èƒ½çš„å­æ•°ç»„ã€‚

##### 8.1.1.Input Format

ç¬¬ä¸€è¡ŒåŒ…å« Tï¼Œåé¢çš„æµ‹è¯•æ•°æ®ç»„æ•°ã€‚ æ¯ç»„æµ‹è¯•æ•°æ®åŒ…å«æ°å¥½ 2 è¡Œã€‚ æ¯ç»„æµ‹è¯•æ•°æ®çš„ç¬¬ä¸€è¡ŒåŒ…å« 2 ä¸ªç©ºæ ¼åˆ†éš”çš„æ•´æ•°å’Œï¼Œæ•°ç»„çš„å¤§å°å’Œæ¨¡ Mã€‚

ç¬¬äºŒè¡ŒåŒ…å« N ä¸ªç©ºæ ¼åˆ†éš”çš„æ•´æ•°ï¼Œè¡¨ç¤ºæ•°ç»„ä¸­çš„æ¯ä¸ªå…ƒç´ ã€‚

##### 8.1.2.Constraints

- 2 â‰¤ N â‰¤ 105

- 1 â‰¤ M â‰¤ 1014

- 1 â‰¤ æ•°ç»„å…ƒç´ çš„å€¼ â‰¤ 1018

- 2 â‰¤ æ‰€æœ‰æµ‹è¯•æ•°æ®ä¸­ N çš„æ€»å’Œ â‰¤ 500000

##### 8.1.3.Output Format

å¯¹æ¯ç»„æµ‹è¯•æ•°æ®ï¼Œåœ¨æ–°çš„ä¸€è¡Œè¾“å‡ºä¸Šé¢è¦æ±‚çš„æœ€å¤§å€¼ã€‚

#### 8.2.Sample

##### 8.2.1.Sample Input

```java
1
5 7
3 3 9 9 5
```

##### 8.2.2.Sample Output

```java
6
```

##### 8.2.3.Explanation

å¯¹ 7 å–ä½™æ•°èƒ½è¾¾åˆ°çš„æœ€å¤§çš„å’Œæ˜¯ 6ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨æ•°ç»„ä¸­çš„ç¬¬ä¸€ä¸ªå…ƒç´ å’Œç¬¬äºŒä¸ªå…ƒç´ å¾—åˆ° 6ã€‚

#### 8.3.Thinking space

1s

2s

3s

4s

5s

6s

7s

8s

9s

10s

#### 8.4.Analysis

[LinkUrl](https://www.quora.com/What-is-the-logic-used-in-the-HackerRank-Maximise-Sum-problem)

I hope I could explain it in a more simple way.!
Before getting into the correct solution, we all know there is a `O(n^2)` algorithm to solve it. We call that Brutal Force solution(BF)

To solve it in a better way, the problem requires some knowledge of modular arithmetic.
Here are some basic formula for this problem:

```java
(ğ‘+ğ‘)%ğ‘€=(ğ‘%ğ‘€+ğ‘%ğ‘€)%ğ‘€ --- 1
(ğ‘âˆ’ğ‘)%ğ‘€=(ğ‘%ğ‘€âˆ’ğ‘%ğ‘€)%ğ‘€ --- 2
```

This link: Modular arithmetic, explains 1, 2 in a straightforward way.

Now, let's solve the problem with the simple math formula!

Usually, a great many problems related to "subarray computation" could be solved with prefix array, which saves time for repeating computation.

Define:

```java
ğ‘ğ‘Ÿğ‘’ğ‘“ğ‘–ğ‘¥[ğ‘›]=(ğ‘[0]+ğ‘[1]+...+ğ‘[ğ‘›])%ğ‘€
```

To construct a prefix table, we could use the following code. (It is a generalization of the 1, 2 formula I mentioned before)

```java
int curr = 0;
for(int i = 0; i < n; i ++) {
  curr = (arr[i] % M + curr) % M;
  prefix[i] = curr;
}
```

The we have to find a subarray. Any subarray can be expressed in the following way:

```java
ğ‘ ğ‘¢ğ‘šğ‘€ğ‘œğ‘‘ğ‘¢ğ‘™ğ‘ğ‘Ÿ[ğ‘–,ğ‘—]=(ğ‘ğ‘Ÿğ‘’ğ‘“ğ‘–ğ‘¥[ğ‘—]âˆ’ğ‘ğ‘Ÿğ‘’ğ‘“ğ‘–ğ‘¥[ğ‘–âˆ’1]+ğ‘€)%ğ‘€ --3
```

which is very simple and efficient.
The correctness of 3 require some math based on 1 and 2. And 3 is the key to the efficient solution!

Let's write the solution of the BF algorithm first:

```java
int ret = 0;
for(int i = 0; i < n; i ++) {
  for(int j = i-1; j >= 0; j --) {
    ret = max(ret, (prefix[i] - prefix[j] + M) % M)
  }
  ret = max(ret, prefix[i]); // Don't forget sum from beginning.
}
```

Okie! This code is simple, however, it did some non-sense job! Why?
if `prefix[j]` is smaller than `prefix[i]`, in the previous code, there is no need to calculate, because for `prefix[j] < prefix[i]`, we have:

```java
(ğ‘ğ‘Ÿğ‘’ğ‘“ğ‘–ğ‘¥[ğ‘–]âˆ’ğ‘ğ‘Ÿğ‘’ğ‘“ğ‘–ğ‘¥[ğ‘—]+ğ‘€)%ğ‘€=ğ‘ğ‘Ÿğ‘’ğ‘“ğ‘–ğ‘¥[ğ‘–]âˆ’ğ‘ğ‘Ÿğ‘’ğ‘“ğ‘–ğ‘¥[ğ‘—]â‰¤ğ‘ğ‘Ÿğ‘’ğ‘“ğ‘–ğ‘¥[ğ‘–]
```

So we just need to find those `j`, which `prefix[j] > prefix[i]`. Ok, let's just linear scan all `j` before i and find the ones that is smaller than `prefix[i]`. But that makes no difference in terms of time complexity.

The only way I could think of is to use a data structure to keep the array sorted. Moreover, the data structure has to support the insert operation. Red black tree can be a great `DS` in this situation. If you are using C++, you can use `set`. Java user could use `TreeSet`.

So every time you get a `prefix[i]`, all previous elements: `prefix[0...i-1]` are in the red black tree, sorted. You need to find the upper_bound of the `prefix[i]`, which is the first element that is larger than the `prefix[i]`. Why we just need the first larger element? The reason is very simple!

The code is very easy to write, if you learn the above ideas. !

#### 8.5.Solution

```java
static long maximumSum(long[] a, long m) {
    int length = a.length;
    long[] pre = new long[length];
    pre[0] = a[0] % m;
    TreeSet<Long> sorted = new TreeSet<>();
    long max = pre[0];
    sorted.add(pre[0]);
    for (int i = 1; i < length; i++) {
        pre[i] = (a[i] % m + pre[i - 1]) % m;
        Long needed = sorted.higher(pre[i]);
        if (needed != null) {
            long current = (pre[i] - needed + m) % m;
            max = Math.max(current, max);
        }
        sorted.add(pre[i]);
        max = Math.max(max, pre[i]);
    }
    return max;
}
```

### 9.Making Candies

[åŸæ–‡ link](https://www.hackerrank.com/challenges/making-candies/problem)

#### 9.1.Description

Karl loves playing games on social networking sites. His current favorite is CandyMaker, where the goal is to make candies.

Karl just started a level in which he must accumulate `n` candies starting with `m` machines and `w` workers. In a single pass, he can make `m x w` candies. After each pass, he can decide whether to spend some of his candies to buy more machines or hire more workers. Buying a machine or hiring a worker costs `p` units, and there is no limit to the number of machines he can own or workers he can employ.

Karl wants to minimize the number of passes to obtain the required number of candies at the end of a day. Determine that number of passes.

For example, Karl starts with `m = 1` machine and `w = 2` workers. The cost to purchase or hire, `p = 1` and he needs to accumulate `60` candies. He executes the following strategy:

Make `m x w = 1 x 2 = 2` candies. Purchase two machines.
Make `3 x 2 = 6` candies. Purchase `3` machines and hire `3` workers.
Make `6 x 5 = 30` candies. Retain all `30` candies.
Make `6 x 5 = 30` candies. With yesterday's production, Karl has `60` candies.
It took `4` passes to make enough candies.

##### 9.1.1.Function Description

Complete the minimumPasses function in the editor below. The function must return a long integer representing the minimum number of passes required.

minimumPasses has the following parameter(s):

- m: long integer, the starting number of machines
- w: long integer, the starting number of workers
- p: long integer, the cost of a new hire or a new machine
- n: long integer, the number of candies to produce

##### 9.1.2.Input Format

A single line consisting of four space-separated integers describing the values of , , , and , the starting number of machines and workers, the cost of a new machine or a new hire, and the the number of candies Karl must accumulate to complete the level.

##### 9.1.3.Constraints

- `1 <= m,w,p,n <= 10^12`

##### 9.1.4.Output Format

Return a long integer denoting the minimum number of passes required to accumulate at least `n` candies.

#### 9.2.Sample

##### 9.2.1.Sample Input

```java
3 1 2 12
asasd
```

##### 9.2.2.Sample Output

```java
3
```

##### 9.2.3.Explanation

Karl makes three passes:

In the first pass, he makes `m x w = 1 x 3 = 3` candies. He then spends `p = 2` of them hiring another worker, so `w = 2` and he has one candy left over.
In the second pass, he makes `3 x 2 = 6` candies. He spends `2 x p = 4` of them on another machine and another worker, so `w = 3` and and `m = 4` he has `3` candies left over.
In the third pass, Karl makes `4 x 3 = 12` candies. Because this satisfies his goal of making at least `12` candies, we print the number of passes (i.e.,`3` ) as our answer.

#### 9.3.Thinking space

1s

2s

3s

4s

5s

6s

7s

8s

9s

10s

#### 9.4.Solution

```java
static long minimumPasses(long m, long w, long p, long n) {
    long candies = 0;
    //investç»Ÿè®¡å®æ—¶çš„è½®æ¬¡ä¿¡æ¯
    long invest = 0;
    //spendç»Ÿè®¡, æœ¬è½®è´­ä¹°åªç”Ÿäº§éœ€è¦çš„è½®æ¬¡(è®°å½•æœ€å°å€¼).
    long spend = Long.MAX_VALUE;

    while (candies < n) {
        // preventing overflow in m*w
        //åœ¨å…ˆå‰æ²¡æœ‰è¶³å¤Ÿçš„é’±è´­ä¹°æœºå™¨æˆ–è€…å·¥äººæ—¶, åªèƒ½å•çº¯çš„ç”Ÿäº§, è®¡ç®—å•çº¯ç”Ÿäº§çš„è½®æ¬¡
        long passes = (long) (((p - candies) / (double) m) / w);

        if (passes <= 0) {
            //å¦‚æœcandies > p, è¯´æ˜å‰©ä½™çš„é’±å¯ä»¥è´­ä¹°æœºå™¨å’Œå·¥äºº

            // machines we can buy in total
            //å°½é‡è¡¥å·®åˆ°ä¸å¤Ÿçš„æ•°é‡é‚£è¾¹, å› ä¸ºè¿™æ ·ä¹˜ç§¯æœ€å¤§
            long mw = candies / p + m + w;
            long half = mw >>> 1;
            if (m > w) {
                m = Math.max(m, half);
                w = mw - m;
            } else {
                w = Math.max(w, half);
                m = mw - w;
            }
            candies %= p;
            //å°†passesèµ‹å€¼1
            passes++;
        }

        // handling overflowing
        // if overflowing is encountered -> candies count are definitely more than long
        // thus it is more than n since n is long
        // so we've reached the goal and we can break the loop
        //è¿™é‡Œè¦æ³¨æ„æº¢å‡º, ä¸€æ—¦æº¢å‡ºä¹Ÿå°±è¯´æ˜å®é™…ä¸Šçš„ç”Ÿäº§æ•°é‡æ»¡è¶³äº†ç›®æ ‡çš„æ•°é‡.
        long mw;
        long pmw;
        try {
            mw = Math.multiplyExact(m, w);
            pmw = Math.multiplyExact(passes, mw);
        } catch (ArithmeticException ex) {
            // we need to add current pass
            invest += 1;
            // increment will be 1 because of overflow
            spend = Math.min(spend, invest + 1);
            break;
        }

        //å°†æœ¬è½®ç”Ÿäº§ç”Ÿäº§çš„ç³–æœç»Ÿè®¡
        candies += pmw;
        //æ·»åŠ æœ¬è½®è®¡ç®—çš„è½®æ¬¡
        invest += passes;
        //è¿™é‡Œè®¡ç®—, å¦‚æœåç»­ä¸å†è´­ä¹°æœºå™¨å’Œäººå·¥æ—¶(åªæ˜¯å•çº¯çš„ç”Ÿäº§), éœ€è¦çš„è½®æ¬¡
        long increment = (long) Math.ceil((n - candies) / (double) mw);
        //å°†æœ¬è½®è¿‡å, ä¸åœ¨è´­ä¹°åªç”Ÿäº§éœ€è¦çš„è½®æ¬¡è®°å½•åˆ°spendä¸­å», spendå–æœ€å°å€¼(å’Œè¿‡å¾€ç›¸æ¯”)
        spend = Math.min(spend, invest + increment);
    }

    //å–ä¸€ç›´è´­ä¹°çš„è½®æ¬¡æ•°é‡å’Œä¸­é—´åœé¡¿è´­ä¹°è½®æ¬¡æ•°é‡çš„è¾ƒå°å€¼.
    return Math.min(spend, invest);
}
```

### 10.Largest Rectangle

[åŸæ–‡ link](https://www.hackerrank.com/challenges/largest-rectangle/problem)

#### 10.1.Description

Skyline Real Estate Developers is planning to demolish a number of old, unoccupied buildings and construct a shopping mall in their place. Your task is to find the largest solid area in which the mall can be constructed.

There are a number of buildings in a certain two-dimensional landscape. Each building has a height, given by `h[i]`. If you join `k` adjacent buildings, they will form a solid rectangle of area `k x min(h[i], h[i+1], ... ,h[i+k-1]`.

For example, the heights array `h=[3,2,3]`. A rectangle of height `h=2` and length `k=3` can be constructed within the boundaries. The area formed is `hxk=2x3=6`.

##### 10.1.1.Function Description

Complete the function largestRectangle int the editor below. It should return an integer representing the largest rectangle that can be formed within the bounds of consecutive buildings.

largestRectangle has the following parameter(s):

- h: an array of integers representing building heights

##### 10.1.2.Input Format

The first line contains n, the number of buildings.
The second line contains n space-separated integers, each representing the height of a building.

##### 10.1.3.Constraints

- `1 <= n < 10^5`
- `1 <= h[i] < 10^6`

##### 10.1.4.Output Format

Print a long integer representing the maximum area of rectangle formed.

#### 10.2.Sample

##### 10.2.1.Sample Input

```java
5
1 2 3 4 5
```

##### 10.2.2.Sample Output

```java
9
```

##### 10.2.3.Explanation

The largest rectangle will be `3 x 3` in the last three rectangle.

#### 10.3.Thinking space

1s

2s

3s

4s

5s

6s

7s

8s

9s

10s

#### 10.4.Solution

```java
static class Rectangle {
    int left;
    int right;
    int height;
    public Rectangle(int left, int height) {
        this.left = left;
        this.height = height;
    }

    public long getArea() {
        return height * (right - left);
    }
}

// Complete the largestRectangle function below.
static long largestRectangle(int[] h) {
    Deque<Rectangle> stack = new ArrayDeque<>();
    stack.push(new Rectangle(0, h[0]));
    long maxArea = 0;
    for (int i = 1; i < h.length; i++) {
        if (stack.size() > 0 && (stack.peek()).height > h[i]) {
            //è¿™å°±æ„å‘³ç€, æ–°è¿›å…¥çš„å»ºç­‘ä¼šç»ˆç»“å‰é¢ä¸€äº›å»ºç­‘æ‰€æ„æˆçš„é•¿æ–¹å½¢.
            Rectangle tr = null;
            Rectangle used = null;
            while (stack.size() > 0 && (tr = stack.peek()).height > h[i]) {
                tr = stack.pop();
                used = tr;
                tr.right = i;
                maxArea = Math.max(maxArea, tr.getArea());
            }
            stack.push(new Rectangle(used.left, h[i]));
        } else {
            //è¿™å°±æ„å‘³ç€, æ–°è¿›å…¥çš„å»ºç­‘ä¼šæ‹“å±•ä¹‹å‰çš„å»ºç­‘ä¸€ä¸ªé•¿åº¦çš„çŸ©å½¢.
            //æ³¨æ„è¿™é‡Œçš„èµ·å§‹ç‚¹ä»å½“å‰å¼€å§‹(å› ä¸ºå½“å‰å»ºç­‘ç›®å‰æ˜¯æœ€é«˜çš„)
            stack.push(new Rectangle(i, h[i]));
        }
    }
    //å‰©ä¸‹åœ¨å †å†…çš„å»ºç­‘éƒ½æ˜¯å¯ä»¥è¾¾åˆ°æ‰€æœ‰é•¿åº¦çš„
    while (stack.size() > 0) {
        Rectangle rt = stack.pop();
        rt.right = h.length;
        maxArea = Math.max(maxArea, rt.getArea());
    }
    return maxArea;
}
```
