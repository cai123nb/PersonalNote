# SQL进阶学习之MYSQL

## 基础知识

### MYSQL的逻辑架构

服务层:

+ 连接/线程处理: 连接处理, 授权认证, 安全等.
+ 核心服务: 查询解析, 查询缓存, 查询优化以及所有内置函数.

存储层:

+ 存储引擎: 负责数据的存储和提取. 提供统一的API与服务层交互, 存在多个不同的实现.

### 事务

#### 基本特性: ACID

+ 原子性(Atomicity): 一个事务必须被视为一个不可分割的最小工作单元, 要不全部提交成功, 要不全部失败回滚.
+ 一致性(Consistency): 数据库总是从一个一致性的状态转换为另外一个一致性的状态.
+ 隔离性(Isolation): 一个事务所做的修改在最终提交之前, 对于其它事务都是不可见的.
+ 持久性(Durability): 一旦事务提交, 所做修改都会永久存储到数据库中.

#### 隔离级别

+ READ UNCOMMITTED: 事务中的修改, 即使没有提交, 对其他事务也是可见的(破坏了隔离性). 会导致`脏读`的情况: 在一个事务A中, 查询到的数据, 恰好别的事务B修改了, 这时候事务A中读取的数据D1是修改之后的, 这时候事务B因为某些原因回滚了. 这时候数据D1就是脏数据(过时数据), 而事务A并不知道.
+ READ COMMITTED: 保证了隔离性, 一个事务开始只能看到自己做的任何修改, 看不到别的事务操作. 但是没有完全解决`脏读`的问题, 如果事务A读取了数据D0, 在这个过程中, 事务B修改了数据D1并提交了, 这时候事务A读取到的数据就是D1. 前后还是存在不一致的问题, 所以也常被称为`NONREPEATABLE READ`.
+ REPEATABLE READ: MYSQL的默认隔离级别, 彻底解决了`脏读`的问题, 保证在任何时候, 多次查询同一个数据都不会存在不一致的情况(使用`快照`的技术). 但是存在`幻读`的情况: 对事务A操作的某一个范围内, 事务B插入了一个对象. 对于事务A来说就存在不一致的情况(好像幻觉一样). 比如事务A对成绩大于90分的同学, 奖学金进行加100操作. 在这个事务执行过程中, 事务B又添加了一名90分以上的同学并提交. 这时候事务A执行完, 就会发现有一个90分的同学没有加奖学金.
+ SERIALIZABLE: 最高的隔离级别, 每次操作都会对行数据加锁. 会带来较大的性能损耗和时间代价.

#### 事务日志

通过事务日志可以提高事务的效率, 每次事务操作, 只需要将操作记录在事务日志里(事务日志是追加的, 不用过分的磁盘检索), 然后修改内存快照即可. 而后再将事务日志的操作慢慢刷新到持久磁盘中. 目前大多数的存储引擎都是这般实现的, 常称为`Write-Ahead Logging`, 预写式日志.

#### 多版本控制

MYSQL中大多数的事务型引擎都不是简单的行级锁, 基于性能的考虑, 一般使用多版本并发控制(`Multiversion Concurrency Control`), 来减少不必要的加锁操作. 以`InnoDB`为例:

+ `SELECT`: 查找符合的条件必须满足两条: 该数据行的事务版本号必须要小于当前事务版本号(保证之前是存在的), 如果存在删除的话, 删除的事务版本号要大于当前的事务版本号(保证事务读取到的行, 当时还没被删除).
+ `INSERT`: 插入的数据行保存当前事务版本号作为行版本号.
+ `DELETE`: 为删除的数据行保存当前事务版本号作为行删除版本号.
+ `UPDATE`: 插入一条新的行记录, 保存当前的事务版本号作为行版本号, 并且作为原来行的行删除版本号.

通过这种多版本控制, 大多数的读操作都不需要加锁, 使的读取更快, 操作简单, 性能更好. 但是需要额外的存储空间, 进行更多的检查操作. 这个只在`REPEATABLE READ`和`READ COMMITTED`两个隔离级别工作.