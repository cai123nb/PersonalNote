# Java闲笔

记录一些和Java相关的笔记.

## 读书小记

Java技术书籍的读书笔记, 该类书籍不适合逐章书写笔记(如`EffectiveJava_3`), 这里简单记录一下图书的重点内容.

### Spring微服务实战(Spring Microservices In Action)

**微服务是什么?**

相对于单体应用来说, 微服务核心为分解和分离应用程序的功能, 使其完全彼此独立.

**为什么要使用微服务架构?**

+ 复杂性的上升, 应用程序不仅仅只是孤立的, 还需要与外部应用进行集成, 甚至通过互联网与外部服务提供商通信.

+ 客户期待更快速的交付, 客户不在期待等待软件一年一次的版本更新, 而是期望项目功能拆分, 以便在几周内快速发布新功能, 而无需等待整个产品的发布.

+ 客户期望应用的高可用性, 应用程序必须具备高度的弹性, 部分故障不应该导致整个程序的崩溃.

而微服务架构为了满足这些需求而提出, 具有`灵活性`, `有弹性`, `可伸缩性`.

**微服务的开发时设计的主题?**

+ 服务粒度, 如何正确的划分业务, 使的每个微服务都具备适当的职责.

+ 通信协议, 服务之间如何进行通信, 开发人员与服务如何进行通信, 主流使用`JSON,XML,Thrift`等.

+ 接口设计, 如何设计实际的服务接口, 便于开发人员调用? 如何版本化服务? 如何构建服务URL来传达服务意图?

+ 服务的配置管理, 如何管理微服务的配置, 便于不同云之间的迁移.

+ 服务之间的事件处理, 如何使用事件解耦微服务, 最小化服务之间的硬编码.

**微服务路由模式?**

微服务的路由模式主要通过两点实现:

+ 服务路由: 所有的服务只提供单个入口点, 便于将安全策略和日志管理应用到所有的服务和服务实例中.

+ 服务发现: 通过动态获取服务列表, 进行动态访问, 防止硬编码, 便于服务列表管理.

![route](https://image.cjyong.com/route.png)

**微服务客户端弹性模式?**

当单个微服务失败之后, 如何快速失败, 优雅降级, 防止影响整个程序:

+ 客户端负载均衡: 客户端缓存服务实例, 动态缓存对应的服务实例地址, 防止定向到失败服务中.(周期和Eureka刷新缓存实例).

+ 断路器模式: 如果调用方法长时间未返回, 则自动中断, 就好像高压断电一样.

+ 后备模式: 如果长时间未返回, 则自动中断, 采用备用的措施进行处理.

+ 舱壁模式: 使用多个分布式资源(如线程池)来进行处理, 防止个别处理缓慢影响所有的服务调用.

**微服务日志记录和跟踪模式?**

将所有的微服务生成的日志通过集合集中记录到可查询的数据库中, 并通过`ZipKin`进行分布式跟踪处理.

**微服务日志记录和跟踪模式?**

详细的代码, 查看[git仓库](https://github.com/carnellj).

![route](https://image.cjyong.com/springCloud.png)

## Transactional

+ PROPAGATION_REQUIRED--支持当前事务, 如果当前没有事务, 就新建一个事务.这是最常见的选择.
+ PROPAGATION_SUPPORTS--支持当前事务, 如果当前没有事务, 就以非事务方式执行.
+ PROPAGATION_MANDATORY--支持当前事务, 如果当前没有事务, 就抛出异常.
+ PROPAGATION_REQUIRES_NEW--新建事务, 如果当前存在事务, 把当前事务挂起.
+ PROPAGATION_NOT_SUPPORTED--以非事务方式执行操作, 如果当前存在事务, 就把当前事务挂起.
+ PROPAGATION_NEVER--以非事务方式执行, 如果当前存在事务, 则抛出异常.

## Sleep/Wait

+ Java中的多线程是一种抢占式的机制, 而不是分时机制(协同式).
+ 共同点:
+ 他们都是在多线程的环境下，都可以在程序的调用处阻塞指定的毫秒数, 并返回.
+ wait()和sleep()都可以通过interrupt()方法打断线程的暂停状态, 从而使线程立刻抛出InterruptedException.
+ 如果线程A希望立即结束线程B, 则可以对线程B对应的Thread实例调用interrupt方法. 如果此刻线程B正在wait/sleep/join, 则线程B会立刻抛出InterruptedException, 在catch() {} 中直接return即可安全地结束线程.
+ 需要注意的是, InterruptedException是线程自己从内部抛出的, 并不是interrupt()方法抛出的. 对某一线程调用interrupt()时, 如果该线程正在执行普通的代码, 那么该线程根本就不会抛出InterruptedException. 但是, 一旦该线程进入到 wait()/sleep()/join()后, 就会立刻抛出InterruptedException.
+ 不同点 ：
+ 每个对象都有一个锁来控制同步访问. Synchronized关键字可以和对象的锁交互, 来实现线程的同步.
+ sleep方法没有释放锁, 而wait方法释放了锁, 使得其他线程可以使用同步控制块或者方法.
+ wait, notify和notifyAll只能在同步控制方法或者同步控制块里面使用(执行的前提是拥有对象锁), 而sleep可以在任何地方使用 .
+ sleep必须捕获异常, 而wait, notify和notifyAll不需要捕获异常.
+ sleep是线程类（Thread）的方法, 导致此线程暂停执行指定时间, 给执行机会给其他线程, 但是监控状态依然保持, 到时后会自动恢复. 调用sleep不会释放对象锁.
+ wait是Object类的方法, 对此对象调用wait方法导致本线程放弃对象锁, 进入等待此对象的等待锁定池, 只有针对此对象发出notify方法(或notifyAll)后本线程才进入对象锁定池准备获得对象锁进入运行状态.

## 按位或逻辑或

+ 用法：condition 1 | condition 2. condition 1 || condition 2
+ "|"是按位或: 先判断条件1, 不管条件1是否可以决定结果(这里决定结果为true), 都会执行条件2.
+ "||"是逻辑或: 先判断条件1, 如果条件1可以决定结果(这里决定结果为true), 那么就不会执行条件2, 这就是熟称的短路判断法.

## 原码, 反码, 补码

+ 原码: 如果机器字长为n, 那么一个数的原码就是用一个n位的二进制数, 其中最高位为符号位: 正数为0, 负数为1. 剩下的n-1位表示概数的绝对值. 如在Java中byte, 就是8字节, 最大的话0111 1111: 最大为127. 如果负数用原码进行表示如 -10: 1000 1010. 其中正负0的值为0000 0000.

+ 反码: 如果是正数, 则反码与原码相同. 如果是负数, 在原码的基础上, 保持符号位不变, 其余位数取反即可. 如10的原码为: 0000 1010, 则反码亦为 0000 1010. -10的原码为: 1000 1010, 则反码为: 1111 0101.

+ 补码: 如果是正数, 则补码与原码相同. 在反码的基础上, 对反码进行加一操作. 如10的原码是: 0000 1010, 反码为0000 1010, 则补码也为0000 1010. -10的原码为: 1000 1010, 则反码为: 1111 0101, 则补码为: 1111 0110. Java中使用补码来表示负数, 如byte为8字节, 由于正负0都为0000 0000. 那1000 0000位最小的负数为: -128. 1000 0000 减一得反码: 0111 1111. 取反的原码: 1000 0000(为-128).

## 面向对象的五大原则

+ 单一职责原则（SRP)
+ 开放封闭原则（OCP)
+ 里氏替换原则（LSP)
+ 依赖倒置原则（DIP)
+ 接口隔离原则（ISP）

## JVM内存小解

+ 大多数 JVM 将内存区域划分为 Method Area(Non-Heap)(方法区), Heap(堆), Program Counter Register(程序计数器), VM Stack(虚拟机栈), Native Method Stack(本地方法栈), 其中Method Area 和Heap 是线程共享的, VM Stack, Native Method Stack和Program Counter Register是非线程共享的.
+ 一个 Java 源程序文件, 会被编译(如javac)为字节码文件(以class 为扩展名, 平台无关字节码文件), 每个java程序都需要运行在自己的JVM上, 然后告知JVM 程序的运行入口, 再被JVM 通过字节码解释器加载(这里暂时不考虑即时编译的问题)运行.
+ 概括地说来, JVM初始运行的时候都会分配好Method Area(方法区)和Heap(堆), 而JVM每遇到一个线程, 就为其分配一个Program Counter Register(程序计数器), VM Stack(虚拟机栈)和Native Method Stack (本地方法栈),  当线程终止时, 三者(虚拟机栈, 本地方法栈和程序计数器)所占用的内存空间也会被释放掉. 这也是内存区域分为线程共享和非线程共享的原因, 非线程共享的那三个区域的生命周期与所属线程相同, 而线程共享的区域与JAVA程序运行的生命周期相同, 所以这也是系统垃圾回收的场所只发生在线程共享的区域(主要是堆)的原因.

![show](https://image.cjyong.com/blog/r1.jpg)

![show](https://image.cjyong.com/blog/r2.jpg)
