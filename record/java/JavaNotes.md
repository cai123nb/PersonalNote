# Java 闲笔

记录一些和 Java 相关的笔记.

## 微服务设计与实战

**微服务是什么?**

相对于单体应用来说, 微服务核心为分解和分离应用程序的功能, 使其完全彼此独立. 主要的特点: **小而自治**.

- 小, 专注做好一件事,保证代码的**内聚性**, 实现**单一职责原则(Single Responsibility Principle)**.
- 自治, 独立管理(构建, 部署), 通过暴露API, 与外部进行隔离, 隐藏内部实现, 从而实现系统的解耦.

**为什么要使用微服务架构?**

- 复杂性的上升, 应用程序不仅仅只是孤立的, 还需要与外部应用进行集成, 甚至通过互联网与外部服务提供商通信.
- 提供技术上的异构性, 允许你通过不同的技术实现不同的模块, 不仅可以定制化模块开发, 还能以一种低廉的成本去尝试新的技术.
- 客户期待更快速的交付, 客户不在期待等待软件一年一次的版本更新, 而是期望项目功能拆分, 以便在几周内快速发布新功能, 而无需等待整个产品的发布.
- 客户期望应用的高可用性, 应用程序必须具备高度的弹性, 部分故障不应该导致整个程序的崩溃.

> 拓展: 可以认为微服务架构是`SOA`的一种实现方式, 一种系统的分解技术. 还有一些其他的分解技术因为没有普适性, 应用的不是特别的广: `共享库`和`模块化`.

而微服务架构为了满足这些需求而提出, 具有`灵活性`, `有弹性`, `可伸缩性`.

**微服务的开发时设计的主题?**

- 服务粒度, 如何正确的划分业务, 使的每个微服务都具备适当的职责.

- 通信协议, 服务之间如何进行通信, 开发人员与服务如何进行通信, 主流使用`JSON,XML,Thrift`等.

- 接口设计, 如何设计实际的服务接口, 便于开发人员调用? 如何版本化服务? 如何构建服务 URL 来传达服务意图?

- 服务的配置管理, 如何管理微服务的配置, 便于不同云之间的迁移.

- 服务之间的事件处理, 如何使用事件解耦微服务, 最小化服务之间的硬编码.

**微服务路由模式?**

微服务的路由模式主要通过两点实现:

- 服务路由: 所有的服务只提供单个入口点, 便于将安全策略和日志管理应用到所有的服务和服务实例中.

- 服务发现: 通过动态获取服务列表, 进行动态访问, 防止硬编码, 便于服务列表管理.

![route](https://image.cjyong.com/route.png)

**微服务客户端弹性模式?**

当单个微服务失败之后, 如何快速失败, 优雅降级, 防止影响整个程序:

- 客户端负载均衡: 客户端缓存服务实例, 动态缓存对应的服务实例地址, 防止定向到失败服务中.(周期和 Eureka 刷新缓存实例).

- 断路器模式: 如果调用方法长时间未返回, 则自动中断, 就好像高压断电一样.

- 后备模式: 如果长时间未返回, 则自动中断, 采用备用的措施进行处理.

- 舱壁模式: 使用多个分布式资源(如线程池)来进行处理, 防止个别处理缓慢影响所有的服务调用.

**微服务日志记录和跟踪模式?**

将所有的微服务生成的日志通过集合集中记录到可查询的数据库中, 并通过`ZipKin`进行分布式跟踪处理.

**微服务日志记录和跟踪模式?**

详细的代码, 查看[git 仓库](https://github.com/carnellj).

![route](https://image.cjyong.com/springCloud.png)

## Transactional

- PROPAGATION_REQUIRED--支持当前事务, 如果当前没有事务, 就新建一个事务.这是最常见的选择.
- PROPAGATION_SUPPORTS--支持当前事务, 如果当前没有事务, 就以非事务方式执行.
- PROPAGATION_MANDATORY--支持当前事务, 如果当前没有事务, 就抛出异常.
- PROPAGATION_REQUIRES_NEW--新建事务, 如果当前存在事务, 把当前事务挂起.
- PROPAGATION_NOT_SUPPORTED--以非事务方式执行操作, 如果当前存在事务, 就把当前事务挂起.
- PROPAGATION_NEVER--以非事务方式执行, 如果当前存在事务, 则抛出异常.

## Sleep/Wait

- Java 中的多线程是一种抢占式的机制, 而不是分时机制(协同式).
- 共同点:
- 他们都是在多线程的环境下，都可以在程序的调用处阻塞指定的毫秒数, 并返回.
- wait()和 sleep()都可以通过 interrupt()方法打断线程的暂停状态, 从而使线程立刻抛出 InterruptedException.
- 如果线程 A 希望立即结束线程 B, 则可以对线程 B 对应的 Thread 实例调用 interrupt 方法. 如果此刻线程 B 正在 wait/sleep/join, 则线程 B 会立刻抛出 InterruptedException, 在 catch() {} 中直接 return 即可安全地结束线程.
- 需要注意的是, InterruptedException 是线程自己从内部抛出的, 并不是 interrupt()方法抛出的. 对某一线程调用 interrupt()时, 如果该线程正在执行普通的代码, 那么该线程根本就不会抛出 InterruptedException. 但是, 一旦该线程进入到 wait()/sleep()/join()后, 就会立刻抛出 InterruptedException.
- 不同点 ：
- 每个对象都有一个锁来控制同步访问. Synchronized 关键字可以和对象的锁交互, 来实现线程的同步.
- sleep 方法没有释放锁, 而 wait 方法释放了锁, 使得其他线程可以使用同步控制块或者方法.
- wait, notify 和 notifyAll 只能在同步控制方法或者同步控制块里面使用(执行的前提是拥有对象锁), 而 sleep 可以在任何地方使用 .
- sleep 必须捕获异常, 而 wait, notify 和 notifyAll 不需要捕获异常.
- sleep 是线程类（Thread）的方法, 导致此线程暂停执行指定时间, 给执行机会给其他线程, 但是监控状态依然保持, 到时后会自动恢复. 调用 sleep 不会释放对象锁.
- wait 是 Object 类的方法, 对此对象调用 wait 方法导致本线程放弃对象锁, 进入等待此对象的等待锁定池, 只有针对此对象发出 notify 方法(或 notifyAll)后本线程才进入对象锁定池准备获得对象锁进入运行状态.

## 按位或逻辑或

- 用法：condition 1 | condition 2. condition 1 || condition 2
- "|"是按位或: 先判断条件 1, 不管条件 1 是否可以决定结果(这里决定结果为 true), 都会执行条件 2.
- "||"是逻辑或: 先判断条件 1, 如果条件 1 可以决定结果(这里决定结果为 true), 那么就不会执行条件 2, 这就是熟称的短路判断法.

## 原码, 反码, 补码

- 原码: 如果机器字长为 n, 那么一个数的原码就是用一个 n 位的二进制数, 其中最高位为符号位: 正数为 0, 负数为 1. 剩下的 n-1 位表示概数的绝对值. 如在 Java 中 byte, 就是 8 字节, 最大的话 0111 1111: 最大为 127. 如果负数用原码进行表示如 -10: 1000 1010. 其中正负 0 的值为 0000 0000.

- 反码: 如果是正数, 则反码与原码相同. 如果是负数, 在原码的基础上, 保持符号位不变, 其余位数取反即可. 如 10 的原码为: 0000 1010, 则反码亦为 0000 1010. -10 的原码为: 1000 1010, 则反码为: 1111 0101.

- 补码: 如果是正数, 则补码与原码相同. 在反码的基础上, 对反码进行加一操作. 如 10 的原码是: 0000 1010, 反码为 0000 1010, 则补码也为 0000 1010. -10 的原码为: 1000 1010, 则反码为: 1111 0101, 则补码为: 1111 0110. Java 中使用补码来表示负数, 如 byte 为 8 字节, 由于正负 0 都为 0000 0000. 那 1000 0000 位最小的负数为: -128. 1000 0000 减一得反码: 0111 1111. 取反的原码: 1000 0000(为-128).

## 面向对象的五大原则

- 单一职责原则（SRP)
- 开放封闭原则（OCP)
- 里氏替换原则（LSP)
- 依赖倒置原则（DIP)
- 接口隔离原则（ISP）

## JVM 内存小解

- 大多数 JVM 将内存区域划分为 Method Area(Non-Heap)(方法区), Heap(堆), Program Counter Register(程序计数器), VM Stack(虚拟机栈), Native Method Stack(本地方法栈), 其中 Method Area 和 Heap 是线程共享的, VM Stack, Native Method Stack 和 Program Counter Register 是非线程共享的.
- 一个 Java 源程序文件, 会被编译(如 javac)为字节码文件(以 class 为扩展名, 平台无关字节码文件), 每个 java 程序都需要运行在自己的 JVM 上, 然后告知 JVM 程序的运行入口, 再被 JVM 通过字节码解释器加载(这里暂时不考虑即时编译的问题)运行.
- 概括地说来, JVM 初始运行的时候都会分配好 Method Area(方法区)和 Heap(堆), 而 JVM 每遇到一个线程, 就为其分配一个 Program Counter Register(程序计数器), VM Stack(虚拟机栈)和 Native Method Stack (本地方法栈), 当线程终止时, 三者(虚拟机栈, 本地方法栈和程序计数器)所占用的内存空间也会被释放掉. 这也是内存区域分为线程共享和非线程共享的原因, 非线程共享的那三个区域的生命周期与所属线程相同, 而线程共享的区域与 JAVA 程序运行的生命周期相同, 所以这也是系统垃圾回收的场所只发生在线程共享的区域(主要是堆)的原因.

![show](https://image.cjyong.com/blog/r1.jpg)

![show](https://image.cjyong.com/blog/r2.jpg)
