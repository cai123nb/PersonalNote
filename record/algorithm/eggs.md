# 鸡蛋掉落问题

![eggs](https://image.cjyong.com/eggs.jpg)

今天来回顾一下一个经典的算法题, 鸡蛋掉落问题. 属于动态规划中经典的例子.

## 简介

你将获得 `K` 个鸡蛋，并可以使用一栋从 `1` 到 `N` 共有 `N` 层楼的建筑。

每个蛋的功能都是一样的，如果一个蛋碎了，你就不能再把它掉下去。

你知道存在楼层 `F`, 满足 `0 <= F <= N` 任何从高于 `F` 的楼层落下的鸡蛋都会碎，从 `F` 楼层或比它低的楼层落下的鸡蛋都不会破。

每次移动，你可以取一个鸡蛋（如果你有完整的鸡蛋）并把它从任一楼层 `X` 扔下（满足 `1 <= X <= N`）。

你的目标是确切地知道 `F` 的值是多少。

无论 `F` 的初始值如何，你确定 `F` 的值的最小移动次数是多少？

### 例子

- `输入：`: K = 1, N = 2
- `输出：`: 2
- `解释：`: 鸡蛋从 1 楼掉落。如果它碎了，我们肯定知道 F = 0 。 否则，鸡蛋从 2 楼掉落。如果它碎了，我们肯定知道 F = 1 。 如果它没碎，那么我们肯定知道 F = 2 。因此，在最坏的情况下我们需要移动 2 次以确定 F 是多少。

### Solution1

经典解决方案思路: 第一个鸡蛋, 当我们选中一个鸡蛋进行投掷时, 假设该层为 `X`, 那么会出现两种情况:

- 鸡蛋碎了, 那么可以肯定, 鸡蛋的临界值在X层以下.
- 鸡蛋没碎, 那么可以肯定, 鸡蛋的临界值在X层以上.

转换为数学公式, 假设 `F(N,K)` 为使用 `N` 个鸡蛋探索 `K` 层的楼所需的最小步数, 当我们随机选中X楼进行投掷会出现两种结果:

- 鸡蛋碎了: 知道鸡蛋的临界值肯定在X层以下. 状态转移为, F(N - 1, X - 1).
- 鸡蛋没碎: 知道鸡蛋的临界值肯定在X层以上(还剩下N-X层). 状态转移为, F(N, N - X).

但是两种情况都有可能, 我们应该取最坏的情况: `MAX(F(N - 1, X - 1), F(N, N - X))`, 最坏情况下通过这些步数也是可以完成测量的. 因此对于`X`层, 我们可以得出以下状态公式:

```java
F(N, K) = MAX(F(N - 1, X - 1), F(N, N - X)) + 1
```

如果我们选择在`X`层进行投掷, 那么我们就需要上面公式所计算的步数. 那么问题的关键在于, 该如何选择`X`层进行投掷, 才会让最终的步数最小呢!! 最简单的方案, 就是从`1`到`N`层, 把去该层进行投掷时, 后面总共需要的步数计算得出, 取其中的最小值, 即为我们的最终解决方案. 即最终的状态公式为:

```java
F(N, K) = MIN[1<=X<=N](MAX(F(N - 1, X - 1), F(N, N - X))) + 1
```

从这个公式我们可以得到初始条件, 当你使用一个鸡蛋时`(N=1)`, 所需的步数即为`K`(需要一层一层向上测试). 当你在`0`楼无论几个鸡蛋都不需要进行测试, `1L`只需要测试一次(如论你几个鸡蛋), `2L`只需要测试两次.

通过上述的初始条件, 就可以依照动态规划构建`F`数组, 动态计算得到`F[N][K]`即可.

#### Solution1-Java

```java
public static int superEggDrop(int eggs, int floors) {
  if (eggs == 1) {
    return floors;
  }

  if (floors == 1) {
    return 1;
  }

  int[][] steps = new int[eggs + 1][floors + 1];

  for (int j = 0; j <= eggs; j++) {
    steps[j][0] = 0;
    steps[j][1] = 1;
    steps[j][2] = 2;
  }

  for (int i = 0; i <= floors; i++) {
    steps[1][i] = i;
  }

  // dynamic calculate
  for (int i = 2; i <= eggs; i++) {
    for (int j = 3; j <= floors; j++) {
      int minSteps = Integer.MAX_VALUE;
      for (int x = 1; x <= j; x++) {
        int currentMax = Math.max(steps[i - 1][x - 1], steps[i][j - x]);
        minSteps = minSteps < currentMax ? minSteps : currentMax;
      }
      steps[i][j] = minSteps + 1;
    }
  }

  return steps[eggs][floors];
}
```

#### 拓展

算法的整体结构基本完成, 但是还可以进行优化. 这里有两个优化的思路:

- 每次判断在那一层进行投掷时, 当前是计算了前往所有的层数的可能性, 然后取了其中的最小值. 这一步可以进行优化. 在该种情况下, `N` 是固定的, 如何选择 `X` 的问题, 即 `K` 的问题. 对于 `F(N,K)` 的单调性我们可知, 对于 `K` 一定是, 单调递增的(如果层数增加了, 步数肯定不会少). 对于`MAX(F(N - 1, X - 1), F(N, N - X))`, 往往是中间的地方所需的步数最少. 因此可以进行二分查找等方法的优化.
- 空间的优化, 我们在使用动态规划计算的时候, 声明了一个 `F[N][K]` 的数组来存储之前的数据, 其实我们每一次计算, 对于 `N` 来说最多往后退一步(`N-1`). 比如计算 `F[3][2]`, 向后最多是到达`F[2][X]`, 对于 `F[1][X]` 及其之前的数据是不会访问到的. 因此其实只需要使用一个 `F[2][K]` 的数组来动态存储所有的数据即可.

### Solution2

切换思路, 逆向思维: 如果我们可以做`T`次操作，而且有`K`个鸡蛋，那么我们能找到答案的最高的`N`(层数)是多少？我们设`F(T, K)`为在上述条件下的`N`, 如果我们求出了所有的`F(T, K)`，那么只需要找出最小的满足`F(T, K) >= N` 的`T`即可。

使用动态规划计算`F(T, K)`. 因为我们需要找出最高的`N`，因此我们不必思考到底在哪里扔这个鸡蛋，我们只需要扔出一个鸡蛋，看看到底发生了什么：

- 如果鸡蛋没有碎，那么对应的是 `F(T - 1, K)`，也就是说在这一层的上方可以有`F(T - 1, K)`层；

- 如果鸡蛋碎了，那么对应的是 `F(T - 1, K - 1)`，也就是说在这一层的下方可以有 `F(T - 1， K - 1)`层。

因此我们就可以写出状态转移方程：

`F(T, K) = 1 + F(T - 1, K - 1) + F(T - 1, K)`

边界条件为：当 `T >= 1`的时候 `F(T, 1) = Tf(T,1)=T`，当 `K >= 1`时，`F(1, K) = 1`。

#### Analysis

发现[LeetCode中hennry](https://leetcode-cn.com/u/hzhu212/)的分析的非常到位, 在此粘贴(如有侵权, 联系删除):

```java
dp[k][m] 表示用 k 个鸡蛋移动 m 步可以“保证求解”的最大楼层数。

我们先解释一下定义中的几个概念：

所谓“求解”，意思就是给定楼层 N，我们能否找到临界楼层 F(F <= N)，使得鸡蛋从 F 层掉落刚好不会被摔碎。所谓“保证求解”，意思就是即使每次丢鸡蛋的结果都很差，最终仍能求解。

比如，给定 1 个鸡蛋移动 1 步，那么可以求解的最大楼层数为 1，即从 1 楼丢下，如果鸡蛋碎了，求得 F=0，如果鸡蛋没碎，求得 F=1。在这种情况下，假如我们给出一个 2 层的楼，就无法保证求解了，因为无论从哪一层丢出鸡蛋，都没有十足的把握能够一次求得 F，换句话说，虽然我们仍有一定的机会能够求解，但无法“保证求解”。

下面回到正题：

假设我们有 k 个鸡蛋可以移动 m 步，考虑某一步 t 应该在哪一层丢鸡蛋？一个正确的选择是在 dp[k-1][t-1] + 1 层丢鸡蛋，结果分两种情况：

如果鸡蛋碎了，我们首先排除了该层以上的所有楼层（不管这个楼有多高），而对于剩下的 dp[k-1][t-1] 层楼，我们一定能用 k-1 个鸡蛋在 t-1 步内求解。因此这种情况下，我们总共可以求解无限高的楼层。可见，这是一种非常好的情况，但并不总是发生。

如果鸡蛋没碎，我们首先排除了该层以下的 dp[k-1][t-1] 层楼，此时我们还有 k 个蛋和 t-1 步，那么我们去该层以上的楼层继续测得 dp[k][t-1] 层楼。因此这种情况下，我们总共可以求解 dp[k-1][t-1] + dp[k][t-1] + 1 层楼。

容易想象，在所有 m 步中只要有一次出现了第一种情况，那么我们就可以求解无限高的楼层。但“保证求解”的定义要求我们排除一切运气成分，因此我们只得认为每次移动都遇到第二种情况。于是得到递推公式：

dp[k][t] = dp[k-1][t-1] + dp[k][t-1] + 1

基本的问题已经解决了，但是我们还遗留了一个问题：为什么要选择在 dp[k-1][t-1] + 1 层丢鸡蛋？

现在我们已经知道，如果我们每一步都在 dp[k-1][t-1] + 1 层丢鸡蛋，最终是一定能够求解的。但如果我们选择在更低的层或者更高的层丢鸡蛋会怎样呢？我们分两种情况讨论：

在更低的楼层丢鸡蛋。同样能够“保证求解”，但最终得到的并不是“最大”楼层数，我们没有充分挖掘鸡蛋数和移动次数的潜力，最终求解时会剩余一定量的鸡蛋或移动次数。

在更高的楼层丢鸡蛋。不妨假设高了一层，即在第 dp[k-1][t-1] + 2 层丢鸡蛋。如果鸡蛋碎掉了，我们仍然可以排除该层以上的所有楼层（不管这个楼有多高），但接下来就不好办了，因为我们剩下的 k-1 个鸡蛋在 t-1 步内只能“保证求解” dp[k-1][t-1] 的楼层，而现在剩余的楼层却是 dp[k-1][t-1] + 1，多了一层，因此无法“保证求解”！

综上，我们用排除法证明了每一步都应该在第 F[k-1][t-1] + 1 层丢鸡蛋。
```

#### Solution2-java

```java
static int superEggDrop2(int eggs, int step) {
  int[][] dp = new int[eggs + 1][step + 1];
  for (int i = 0; i <= step; ++i) {
    dp[1][i] = i;
  }

  for (int i = 2; i <= eggs; ++i) {
    for (int j = 1; j <= step; ++j) {
      dp[i][j] = dp[i][j - 1] + dp[i - 1][j - 1] + 1;
      if (dp[i][j] >= step) {
        return j;
      }
    }
  }
  return step;
}
```

## 参考文档

- [LeetCode](https://leetcode-cn.com/problems/super-egg-drop/)
- [Henry](https://leetcode-cn.com/u/hzhu212/)
- [Dynamic programming](https://en.wikipedia.org/wiki/Dynamic_programming)
