# 技术分享

大家好, 我是来自工程技术管理的蔡剑勇, 入职招银也有两个多月了, 可能很多人都还不认识我, 这里简单地和大家介绍一下自己, 大家好, 我叫蔡剑勇, 江西赣州人, 毕业于西南大学软件工程专业, 很高兴来到招银这个大家庭认识大家.

## 首页

今天主要给大家分享一下看板项目中前端的设计和开发. 之前广洋也给大家介绍过看板前端的设计, 那次我已经在招银, 讲的很好, 非常通俗易懂. 所以今天会选取一些比较重要的部分, 较为深入地给大家介绍一下, 大家有什么问题都可以提出来, 我尽量解答. 如果暂时解答不了, 就等我下来查阅相关资料后, 通过招呼或者邮件告知你.

## Main Content

今天内容的重点主要涉及4个方面, 首先就是介绍前端项目的总览, 然后会比较深入的介绍一下Angular框架, 最后简单介绍一下项目涉及的比较重要的技术栈: Jest, Ngrx.

## 前端项目

首先项目分成两部分, 一部分是主体业务程序, 另一部分则是以`cmbkb-component`为主的组件库. 组件库主要是存储看板项目用到的一些前端组件, 从主体业务程序中剥离出来, 以包依赖的方式引入到主体业务程序中. 而主体业务程序则是包含了所有的业务代码, 真正部署上线的前端程序. (为什么要拆分? 主要是为了保证组件代码的纯洁, 业务代码的清晰, 多团队合作).

当然两个项目都是以Angular框架为核心开发的, 由Angular CLI脚手架生成. 项目里面使用的包管理器是NPM, 并不是YARN. 开发语言的话, 选用的是TypeScript和Scss.

TypeScript是JavaScript的一个超集, 由微软公司发布的一个JavaScript标准, 主要内容是对Java Script ES6的一个补充, 其中由C#的首席架构师安德斯·海尔斯伯格参与开发, 引入了很多面向对象的一些概念, 如接口, 泛型, 枚举, 静态类型检查等功能.

SCSS和CSS有什么关系呢? SCSS 是 Sass 3 引入新的语法，其语法完全兼容 CSS3，并且继承了 Sass 的强大功能。Sass是css的拓展语言, 通过解释器动态转换为常规css文件. 刚开始sass语言最初解释器是由Ruby开发的, 并且内部实现的语法和Ruby非常像, 非常复杂, 难懂且不兼容CSS的默认语法. 后面Sass就引入了SCSS语法, 完全兼容CSS3的语法, 并且继承了Sass的优点, 如预定义变量, 函数声明, 动态导入等等. 项目使用的样式就是用scss编写的.

项目的主体代码格式化和美化使用的是Prettier和TSlint, 设计的技术栈有: Angular, Jest, Ngrx, Graphql等等.

## Angular

接下来, 给大家详细的介绍一下Angular框架.

首先, 我们先简单的了解一下Angular的历史.

### Angular - history

2010年: Google公司的工程师Misko Hevery被安排一项比较边缘项目: 开发一套协助公司内部web应用构建的工具. 这个工具也就是大家所知的`Angular JS`项目了. 后来Misko Hevery一批人就开始基于`Angular JS`开发一些Web应用, 并在2010年进行了开源.

2014 — 2015年: 这段时间前端的发展非常迅猛, JS的标准从2009年的ES5也发展道路2015年的ES6, 各种前端框架和设计理念开始高速发展. Angular JS开始慢慢落伍了. Google公司看中了前端发展的前景, 想要将Angular JS开发成一套企业级的, 支持各平台的前端框架. 很快就发现各种问题, 首先之前Angular JS开发团队非常小不支持这样复杂的开发, 其次Angular设计之初就没有考虑过要向企业级产品发展, 内部设计陈旧, 很多功能无法实现. 最后Google公司决定放弃AngularJS, 进行彻底重写, 并发布了Angular2.

2016年: 对于使用了Angular JS的开发者是非常痛苦的, 首先Angular JS和Angular 2两者完全不同, Angular2完全不兼容Angular JS, 且设计上超前地引入了很多概念如模块, 组件, 服务, 依赖注入, 元数据. 并且官方没有一个正式的迁移方案. 对于使用Angular JS的人来说, 这仿佛就是一个新的语言, 必须从零开始.

2017 — 2019年: 这段时间, Angular从2.0版本一直稳步发展到了8.0版本, 随着版本的更替, Angular变得越来越稳定, 打包的项目也越来越小, 各方面的功能支持也越来越好. 也慢慢的吸引了开发者的喜好, 特别是在开发复杂的企业应用上面.

从现在来看, 这个重写的代价是值得的, 没有这次重写, 可能Angular就会像JQuery一样慢慢地淘汰在前端的浪潮中.当然现在, Angular也在慢慢支持AngularJS, 并发布到了1.7版本. 也提供了官方的迁移文档.

### Angular - version choose

这里简单介绍一下Angular的版本控制, 自从Angular2开始, Angular就遵从语义化版本控制模式, 版本升级分为三个版本: 主版本号(像2.0, 3.0, 5.0), 一般六个月发布一次, 包含重大的功能更新, 但是不兼容以前的旧版本. 比如你从2.0升级到了3.0, 你就需要更新的你的代码, 重构部分逻辑, 进行额外的测试保证代码的稳定性等. 次版本号(就像2.1, 2.2, 2.3), 一般一次主版本期间会有1到3次次版本更新, 一般涉及到小的功能点, 是向后兼容的. 最后就是修订号, 像2.1.0, 2.1.1等. 主要是一些bug修复, 风险的修复, 也是向后兼容的.

Angular承诺对主版本一般支持18个月, 其中6个月的积极维护(包括一些次版本的更新, 修订号的更新). 12个月的长期维护(只能是修订号的更新, 比如风险修复等). 现在最新的版本是Angular8. 项目使用的是Angular7, 已经进入到了长期维护阶段. 项目前端准备在今年进行版本的升级.

### Angular - Architecture

Angular内部设计主要分为三部分: Components, Services, Module.

Components: 就是对应我们看到的每一个视图元素, 如按钮, 菜单, 页面等等. 每个组件内部存储和组件相关的数据和逻辑.

Services: 则是对应服务层, 不直接和视图关联, 但是可以被注入到各个组件中.

Module: 则是对应的Angular内部的模块系统NgModules, 注意和JS自身的模块相互区分. 内部提供了一个集合的上下文, 内部可以包含一个或者多个的组件, 依赖的组件, 注入的服务, 配置等等.

就是通过这三个简单的设计, 组成了Angular复杂的系统.

### Angular - Component - 1

这里看一个简单的组件声明:

首先类上面的, 类似Java注解的部分, 在Angular中称为元数据, 用以联通模板样式和组件的联系.

@Component: 首先通过@Component来声明这是一个组件.
selector: CSS的选择器, 告诉Angular, 如果页面中使用了类似<>包围的时候, 就会创建一个实例, 嵌套进去. 这里可以看一个别的例子.
templateUrl: 组件对应模板文件的位置, 就是需要渲染的HTML结构.
styleUrls: 组件对应的样式文件位置, 内部定义了模板文件的对应的样式.

### Angular - Component - 2

接下来, 我们看一个简单的模板文件: 可以看到,在合理不仅可以使用原生的HTML标签, 还可以引用其他组件, 共同构成一个新的组件.

### Angular - Component - 3

这里我们可以看出, 模板文件是如何与组件进行数据绑定的, 主要分为三种方式:

+ 第一种是直接获取, 通过两个大括号可以访问到组件内部定义的`public`的对象.
+ 第二种是通过[]进行数据传递, 可以将父组件中的信息, 传递给子组件.
+ 第三种就是绑定事件触发器, 这里绑定了一个点击触发事件, 触发的函数则是在组件内部实现的.

### Angular - Service - 1

这里可以看到一个简单的Service实现, 日志Service, 进行日志输出. 可以看出, 这里的实现只是简单地在控制台输出.

首先通过@Injectable: 声明这是一个服务类. 然后注意这里的`provideIn`这意味着这个服务要在那些地方使用, 可以注册到全局, 某些特定模块, 或者一些特殊的组件中去. 这里注册的是全局, Angular会在全局创建一个共享的服务单例, 任何模块或者组件需要使用的时候, 只要在声明的时候使用`provide`注入进去即可.

### Angular - Service - 2

这个图可以清晰的看出, Angular Service是动态注入的, Angular内部维护这个实例对象. 如果我们在某个组件中需要使用的话, 就在构造函数中声明即可. 是不是感觉和Spring的依赖注入很像, Angular设计也参照了这种模式.

### Angular - Module

首先通过@NgModule声明一个模块:

+ imports: 则是声明这个模块依赖的其他模块, 这里导入了`BrowserModule`.
+ providers: 这里是注入这个模块所需要的服务, 这里导入了上面声明的`Logger`的服务, 这样我们在模块内部就不用单独导入, 直接使用就可以了.
+ declarations: 则是声明属于这个模块的组件, Directive等, 一般的一个组件只能在一个模块中声明, 否则会报错.
+ exports: 需要导出的组件, 模块内部的组件, 如果需要被模块外部使用, 就需要在这里导出, 这里导出AppComponent组件.
+ bootstrap: 这里声明根组件, 用于承载所有的组件. 一般只有根模块才能设置这个属性, 这里定义的根组件为: AppComponent组件.

Angular至少有一个模块, 那就是根模块. Angular是从根模块引导启动的.

这里就是Angular的三大基本组件, 相信大家有了一个基本的概念, 大家有兴趣地可以深入学习一下.

## Jest

测试框架用到的就是Jest. 项目的开发一般是基于TDD模式开发, 也是使用JEST来编写测试代码.

Jest是Facebook出品的一套轻量级的测试框架. Angular CLI默认使用的测试框架是jasmine, 项目之前使用的也是jasmine, 和jasmine相比, jest最大的特点就是快和简单. Jest拥有以下特点:

+ Zero config: Jest的设计目标就是开箱即用, 尽量减少配置.
+ Snapshots: Jest支持快照, 当我们不小心误删某一个属性或者模板标签时, 就会和快照不一致, 这时候就可以很容易地检查出来.
+ Isolated: Jest内部的测试运行是并行的, 就是可以同时跑多个测试, 可以很好提高效率.
+ Great api: Jest提供了丰富的API接口, 文档, 很方便用户从其他测试框架迁移到Jest.

### Jest - fast and safe

Jest因为在后台并行跑, 所以速度很快. 并且, Jest还会优先运行上次挂掉的测试, 并按照测试花费的时间进行排序运行.

### Jest - easy mocking

Jest使用的是自定义解析器, 如果你的测试对象依赖外部的一些属性或者行为, 你可以通过Jest模拟你需要的属性和动作, 而不是创建他们. 这样可以带来很高的效率.

### Jest - code coverage

Jest可以从整个项目中收集代码覆盖率信息，包括未经测试的文件。

### Jest - great exception

Jest 当我们测试失败的时候, Jest可以提供丰富的上下文信息, 让我们很容易就追踪到出错原因.

## Ngrx

现在的web应用一般都是单页面应用(和传统的多页面应用相比, 减少了页面重新获取和渲染, 将复杂度从后台转移到了客户端浏览器, 更少的服务器支持更多的用户), 这样做和传统的多页面模式有很多好处. 这里就不详细展开. 当项目越来越大, 复杂度越来越高的时候, 需要前端需要存储的数据也越来越多, 设计的组件也变得很多. 如看板里面存储的数据有: 用户信息, 卡片信息, 泳道信息, 标签信息, 室组信息等等. 如果你在卡片详情页改变了卡片信息, 那么在卡片缩略图, 全景模式小卡, 其他板都需要更新这个信息. 这个时候数据管理也就成了一个复杂的问题.

项目引入了一套数据管理系统, Ngrx. ngrx是受到Redux启发, 核心很多概念都和Redux非常的像. 主体分为四部分, 这里以后端的数据库为例进行讲解, 个人理解可能有点偏差.

Action: 类似于后台中的增加,删除,修改的SQL语句, 我们先预定义好名称, 当我们需要使用的时候, 就把这些预定义好的SQL语句发送给数据库.
State: 可以理解为数据库中存储的信息.
Reducers: 可以理解为数据库的执行者(可以认为是执行引擎), 处理不同的SQL -> Action和查询语句.
Selector: 可以理解为从数据库中自定义查询语句, 有时候我自需要部分字段, 这时候就需要用Selector进行自定义查询.

接下来, 我们看一个简单的例子

### Ngrx - Action

要使用Ngrx, 我们要先定义好Action, 可以理解为先定义好SQL脚本. 这里定义了三种语句: 增加, 删除和重置.

### Ngrx - state

然后呢, 我们就可以定义我们的数据库state, 这里就只存储了initialState一个信息. 接下来, 我们定义一下数据库的执行者Reducer, 这里声明了遇到不同的Action可以对数据库的数据进行不一样的操作. 如增加, 让初始值加一.

### Ngrx - import

然后呢, 将这个数据库引入到对应的模块. 如果某个模块需要使用到这个Ngrx, 引入就可以了.

### Ngrx - use

然后这里是一个简单的使用场景, 可以看出组件中使用, 只需要向数据库Ngrx发送对应的SQL语句, Action就可以了.

看起来是不是非常容易理解. 很多东西和后端的想法和理念都是想通的.

## Thanks

最后到这里, 我的分享就结束了. 大家有什么问题, 都可以提出来, 或者在招呼邮件上和我说. 非常感谢大家来参与我的分享, 希望大家有所收获., 谢谢.
