# 浅析看板前端设计

## 主体设计

看板前端主要以`Angular`框架为核心, 项目由`[Angular CLI](https://github.com/angular/angular-cli)`生成. 使用`npm`(这里没有使用`yarn`)作为包管理工具, 在代码格式化和美化方面主要使用`prettier`和`tslint`.

项目主要涉及的技术栈有: `Angular`, `Apollo`, `CDK`, `Jest`等等.

这里选取几个比较重要的技术栈进行较为深入的讲解.

## Angular

### short history

+ **2010: The birth of AngularJS**:
  + a Google employee by the name of Miško Hevery, was developing a side project. This side project was to help make building web applications easier for a couple internal projects he was working on. This side project later became known as AngularJS. 
  + Misko and a few others started to create a few more internal applications with AngularJS, eventually releasing it as an open source project in 2010.
+ **2014 — 2015: The Great Rewrite**:
  + Several years after its initial release, the landscape of web development started to change and AngularJS hit a wall. New advancements and standards in JavaScript emerged, and Angular started to get left behind the bleeding edge((2009 Java script: ECMAScript 5 (2009) -> 2015 ECMAScript 2015(JS ES6))).
  + The team at google and community took what was once a small internal project and pushed it to new frontiers like mobile and large enterprise applications.
  + However, it was never intended or designed for these situations when Miško first created it. With every pull request we modified
  + AngularJS the best we could to fit our needs.When the core team at Google sought to deliver 2.0, they didn’t want to be shackled to their previous design of AngularJS. They wanted to build a framework from the ground up to solve difficult problems when building large and cross-platform applications. That meant a total rewrite.
+ **2016: The Panic Period**:
  + Developers and managers alike started to freak out. The complete rewrite meant a doomsday scenario for their current AngularJS projects running in production. “How can we support this application in 3, 5, or 6 years from now?!”
  + Even worse, their was no clear migration strategy to port an AngularJS 1.X application to the new Angular 2.0.
  + Teams jumped the gun and started to build new Angular2.0 apps while it was still in beta. The thought was “I better get going if this is going to be a total rewrite”.What they found was a lot of frustrating new concepts and breaking changes with every release. It was at this point teams quickly started to turn their back on AngularJS for libraries like React.
+ **2017 — 2018: Emerging from the rubble**:
  + Fast forward to 2018 and the Angular framework has reached several major releases in efforts to stabilize their framework. Each release bringing better build sizes, stable APIs, and overall better performance.
  + It was a heavy price to pay, but the team ultimately redesigned Angular from the ground up to give us more than we ever had in 1.x. Unlike libraries such as React, Angular really provides solutions at every corner of building a large application. Libraries like React still require outside projects to fill in the missing pieces to our project. There are pros and cons to both, but thats another topic for another time.
  + ![img](https://cdn-images-1.medium.com/max/1600/1*ifuv_0NRxicEWbZc3YR7Qg.png)

+ **Going Forward**: 
  + As for our old friend AngularJS, it’s still supported. The core team recently announced it will release a final 1.7 and move into long-term support.
  + Does Angular have some catching up to do? Sure. But the gap is small enough to not be of concern. The benefits of operating in a unified framework can outweigh a fragmented landscape for some teams.
  + With stable APIs and plenty of open source projects to power our apps, the project is more than capable of producing great applications for large teams.

### version choose

[Semantic Versioning Control](https://semver.org/#semantic-versioning-200)

+ Major releases contain significant new features, some but minimal developer assistance is expected during the update. When updating to a new major release, you may need to run update scripts, refactor code, run additional tests, and learn new APIs.  **A major release every 6 months**
+ Minor releases contain new smaller features. Minor releases are fully backward-compatible; no developer assistance is expected during update, but you can optionally modify your apps and libraries to begin using new APIs, features, and capabilities that were added in the release. We update peer dependencies in minor versions by expanding the supported versions, but we do not require projects to update these dependencies. **1-3 minor releases for each major release**.
+ Patch releases are low risk, bug fix releases. No developer assistance is expected during update. **A patch release almost every week**.

All of our major releases are supported for 18 months.
+ 6 months of active support, during which regularly-scheduled updates and patches are released.
+ 12 months of long-term support (LTS), during which only critical fixes and security patches are released.

|VERSION|	STATUS|	RELEASED|	ACTIVE ENDS|	LTS ENDS|
|---|---|---|---|---|
|^8.0.0	|Active|	May 28, 2019|	Nov 28, 2019|	Nov 28, 2020|
|^7.0.0	|LTS	| Oct 18, 2018	| Apr 18, 2019| Apr 18, 2020|
|^6.0.0	|LTS	 | May 3, 2018	| Nov 3, 2018	| Nov 3, 2019 |

2,3,4,5 no longer support.

choose: 7.

### Architecture overview

Angular is a platform and framework for building client applications in HTML and TypeScript. Angular is written in TypeScript. It implements core and optional functionality as a set of TypeScript libraries that you import into your apps. (what is TypeScript: TypeScript是Microsoft公司开发的一个JavaScript的超集。它可以编译成普通的JavaScript代码。 TypeScript支持任意浏览器，任意环境，任意系统并且是开源的。TypesScript is known as Object oriented programming language whereas JavaScript is a scripting language. 引入了接口,静态变量,类型校验等功能).

+ `Components` define views, which are sets of screen elements that Angular can choose among and modify according to your program logic and data.
+ Components use `services`, which provide specific functionality not directly related to views. Service providers can be injected into components as dependencies, making your code modular, reusable, and efficient.
+ `module`: Angular apps are modular and Angular has its own modularity system called NgModules. NgModules are containers for a cohesive block of code dedicated to an application domain, a workflow, or a closely related set of capabilities. They can contain components, service providers, and other code files whose scope is defined by the containing `NgModule`.

+ The metadata for a component class associates it with a template that defines a view. A template combines ordinary HTML with Angular directives and binding markup that allow Angular to modify the HTML before rendering it for display.
+ The metadata for a service class provides the information Angular needs to make it available to components through dependency injection (DI).

#### components

```js
@Component({
  selector:    'app-hero-list',
  templateUrl: './hero-list.component.html',
  providers:  [ HeroService ]
})
export class HeroListComponent implements OnInit {
/* . . . */
}
```

```html
<h2>Hero List</h2>

<p><i>Pick a hero from the list</i></p>
<ul>
  <li *ngFor="let hero of heroes" (click)="selectHero(hero)">
    {{hero.name}}
  </li>
</ul>

<app-hero-detail *ngIf="selectedHero" [hero]="selectedHero"></app-hero-detail>
```

```html
<li>{{hero.name}}</li>
<app-hero-detail [hero]="selectedHero"></app-hero-detail>
<li (click)="selectHero(hero)"></li>
```

```html
<!-- Default format: output 'Jun 15, 2015'-->
 <p>Today is {{today | date}}</p>

<!-- fullDate format: output 'Monday, June 15, 2015'-->
<p>The date is {{today | date:'fullDate'}}</p>

 <!-- shortTime format: output '9:43 AM'-->
 <p>The time is {{today | date:'shortTime'}}</p>
```

#### service

declare:

```js
export class Logger {
  log(msg: any)   { console.log(msg); }
  error(msg: any) { console.error(msg); }
  warn(msg: any)  { console.warn(msg); }
}
```

use:

DI:

```js
constructor(private service: HeroService) { }
```

#### module

```ts
import { NgModule }      from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';
@NgModule({
  imports:      [ BrowserModule ],
  providers:    [ Logger ],
  declarations: [ AppComponent ],
  exports:      [ AppComponent ],
  bootstrap:    [ AppComponent ]
})
export class AppModule { }
```

+ An NgModule is defined by a class decorated with @NgModule(). The @NgModule() decorator is a function that takes a single metadata object, whose properties describe the module. The most important properties are as follows.
+ declarations: The components, directives, and pipes that belong to this NgModule.
+ exports: The subset of declarations that should be visible and usable in the component templates of other NgModules.
+ imports: Other modules whose exported classes are needed by component templates declared in this NgModule.
+ providers: Creators of services that this NgModule contributes to the global collection of services; they become accessible in all parts of the app. (You can also specify providers at the component level, which is often preferred.)
+ bootstrap: The main application view, called the root component, which hosts all other app views. Only the root NgModule should set the bootstrap property.

## JEST

Jest is a delightful JavaScript Testing Framework with a focus on simplicity. Jest is a JavaScript testing framework designed to ensure correctness of any JavaScript codebase. It allows you to write tests with an approachable, familiar and feature-rich API that gives you results quickly. FaceBook出品,轻量级的测试工具.

+ zero config: Jest aims to work out of the box, config free, on most JavaScript projects.
+ snapshots: Make tests which keep track of large objects with ease. Snapshots live either alongside your tests, or embedded inline.
+ isolated: Tests are parallelized by running them in their own processes to maximize performance.
+ great api: From it to expect - Jest has the entire toolkit in one place. Well documented, well maintained, well good.

+ FAST AND SAFE: By ensuring your tests have unique global state, Jest can reliably run tests in parallel. To make things quick, Jest runs previously failed tests first and re-organizes runs based on how long test files take.
+ EASY MOCKING: Jest uses a custom resolver for imports in your tests making it simple to mock any object outside of your test’s scope. You can use mocked imports with the rich Mock Functions API to spy on function calls with readable test syntax.
+ CODE COVERAGE: Generate code coverage by adding the flag --coverage. No additional setup needed. Jest can collect code coverage information from entire projects, including untested files.
+ GREAT EXCEPTIONS: Tests fail, when they do Jest provides rich context why, here’s some examples.

Example:

```ts
```

### ngrx

NgRx is a framework for building reactive applications in Angular. NgRx provides state management, isolation of side effects, entity collection management, router bindings, code generation, and developer tools that enhance developers experience when building many different types of applications.


Store is RxJS powered state management for Angular applications, inspired by Redux. Store is a controlled state container designed to help write performant, consistent applications on top of Angular.

+ Actions describe unique events that are dispatched from components and services.
+ State changes are handled by pure functions called reducers that take the current state and the latest action to compute a new state.
+ Selectors are pure functions used to select, derive and compose pieces of state.
+ State accessed with the Store, an observable of state and an observer of actions.

```js
import { createAction } from '@ngrx/store';

export const increment = createAction('[Counter Component] Increment');
export const decrement = createAction('[Counter Component] Decrement');
export const reset = createAction('[Counter Component] Reset');
```

```js
import { createReducer, on } from '@ngrx/store';
import { increment, decrement, reset } from './counter.actions';

export const initialState = 0;

export const counterReducer = createReducer(initialState,
  on(increment, state => state + 1),
  on(decrement, state => state - 1),
  on(reset, state => 0),
);
```

```js
import { BrowserModule } from '@angular/platform-browser';
import { NgModule } from '@angular/core';
 
import { AppComponent } from './app.component';
 
import { StoreModule } from '@ngrx/store';
import { counterReducer } from './counter.reducer';
 
@NgModule({
  declarations: [AppComponent],
  imports: [
    BrowserModule,
    StoreModule.forRoot({ count: counterReducer })
  ],
  providers: [],
  bootstrap: [AppComponent],
})
export class AppModule {}
```

```js
import { Component } from '@angular/core';
import { Store, select } from '@ngrx/store';
import { Observable } from 'rxjs';
import { increment, decrement, reset } from '../counter.actions';

@Component({
  selector: 'app-my-counter',
  templateUrl: './my-counter.component.html',
  styleUrls: ['./my-counter.component.css'],
})
export class MyCounterComponent {
  count$: Observable<number>;

  constructor(private store: Store<{ count: number }>) {
    this.count$ = store.pipe(select('count'));
  }

  increment() {
    this.store.dispatch(increment());
  }

  decrement() {
    this.store.dispatch(decrement());
  }

  reset() {
    this.store.dispatch(reset());
  }
}
```

Fun Fact: Angular vs AngularJS
AngularJS 1.x always kept the 1 in its versioning. Whether it was a breaking change or not, the major version was always 1.x.x

With Angular 2.0 the team has since decided to follow semantic versioning practice of (Major).(Minor).(Patch). If any breaking change is introduced into a new release, it bumps up the major version. Since the initial release there have been around 3 breaking changes (FYI: we skipped version 3 going from 2 → 4 to get several angular packages in alignment)



[Semantic Versioning 2.0.0](https://semver.org/#semantic-versioning-200)


https://medium.com/the-startup-lab-blog/the-history-of-angular-3e36f7e828c7