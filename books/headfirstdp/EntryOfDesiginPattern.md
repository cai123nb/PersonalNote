# Base

Joe 上班的公司做了一套相当成功的模拟鸭子游戏: SimUDuck. 游戏中会出现各种鸭子, 一边游戏戏水, 一边呱呱叫. 系统内部的设计采用标准的 OO(Object Oriented)技术, 设计了一个鸭子超类(Superclass), 并让各种鸭子继承此超类.

| Duck      | class    |
| :-------- | -------- |
| quack()   | 父类实现 |
| swim()    | 父类实现 |
| display() | 抽象的   |

| MallardDuck | class        |
| :---------- | ------------ |
| display()   | 外观是绿头的 |

| RedHeadDuck | class        |
| :---------- | ------------ |
| display()   | 外观是红头的 |

## Change1

主管们确定要创新, 模拟程序中需要让鸭子可以飞起来.

**最初思路**: 只需要在 Duck 类中添加添加 fly 方法, 由父类进行实现, 那么所有的 Duck 的子类都可以飞起来了.

| Duck      | class           |
| :-------- | --------------- |
| quack()   | 父类实现        |
| swim()    | 父类实现        |
| fly()     | (添加) 父类实现 |
| display() | 抽象的          |

这样鸭子的子类自动继承该方法, 就实现了飞起来的功能.

**出现的问题**: 某些不能飞行的子类也飞起来了, 如橡皮鸭(RubberDuck). 并非所有的 Duck 的子类都会飞, 只是修改一个地方, 全都都发生了改变.

这时候我们观察到:

| RubberDuck | class                |
| :--------- | -------------------- |
| quack()    | 覆盖父类, 变成吱吱叫 |
| display()  | 外观是橡皮鸭         |

**解决方法**: 我们可以将橡皮鸭中的 fly()方法覆盖掉, 就像覆盖 quack()做法一样.

利用继承导致的问题:

1. 改变牵一发动全身, 造成其他鸭子都不想要的改变
2. 很难知道所有鸭子的行为
3. 运行时行为不容易改变
4. 代码在多个子类中重复.

**新的思路**: 如果我们采用接口怎么样:

| Duck      | class    |
| :-------- | -------- |
| swim()    | 父类实现 |
| display() | 抽象的   |

| Flyable | interface |
| :------ | --------- |
| fly()   | 抽象的    |

| Quackable | interface |
| :-------- | --------- |
| quack()   | 抽象的    |

如果某些子类需要某项功能, 只需要实现该接口即可.

**出现的问题**: 重复代码就会巨增, 导致代码无法复用.

## 问题归零

有一个设计原则可以很好的解决这个问题:

**找出应用中可能需要变化之处, 把它们独立出来, 不要和那些不需要变化的代码混在一起.**

> 把会变化的部分取出, 并封装起来, 好让其他部分不受到影响. 系统变化引起的不经意的后果减少, 系统变得更加有弹性.

**分离变化和不会变化的部分**:

1. 不变化: Duck 类, 仍然是所有的鸭子的超类, 但是飞行和呱呱叫行为已经被取出, 放到别的类结构里.
2. 变化: 飞行行为和呱呱叫行为.

**如何设计变化的行为部分**:

我们希望一切能有弹性, 毕竟, 正是因为一开始鸭子的行为没有弹性才让我们走上这条路. 我们可以参照第二个设计原则:

**针对接口编程, 而不是针对实现编程.**

> 我们可以将鸭子的行为放到分开的类中, 这个类专门提供某行为接口的实现, 这样鸭子类就不在需要知道行为的实现细节.

| FlyBehavior | Interface |
| :---------- | --------- |
| fly()       | 抽象的    |

| FlyWithWings | Class              |
| :----------- | ------------------ |
| fly()        | 实现鸭子的飞行动作 |

| FlyNoWay | Class              |
| :------- | ------------------ |
| fly()    | 什么都不做, 不会飞 |

实现接口编程意味着: 针对超类型编程(SuperType). 超类型一般为一个接口或者一个抽象类, 只要是具体实现了此超类型的类所产生的对象, 都可以指定给这个变量, 这也就意味着声明类时不需要理会以后执行时的真正对象类型. 如: 假设有个抽象类 Animal, 有两个具体实现 Dog 和 Cat 继承 Animal.

```java
//针对实现编程
Dog d = new Dog();
d.bark();

//针对接口编程
Animal animal = new Dog();
animal.makeSound();
```

## 整合鸭子的行为

| Duck                        | class                               |
| :-------------------------- | ----------------------------------- |
| FlyBehavior flyBehavior     | 接口成员变量                        |
| QuackBehavior quackBehavior | 接口成员变量                        |
| perormQuack()               | 调用 quackBehavior 中的 quack()方法 |
| performFly()                | 调用 flyBehavior 中的 fly()方法     |
| swim()                      | 父类实现                            |
| display                     | 抽象的                              |

```java
public class MallardDuck extends Duck {
   public MallardDuck() {
       quackBehavior = new Quack();
        flyBehavio = new FlyWithWings();
    }
    public void display() {
       System.out.println("I'm a real Mallard duck");
    }
    //...
}
```

如果我们需要动态设定行为: 我们可以在 Duck 父类中添加两种行为的 set 函数, 这样我们可以动态设定不同的行为表现形态.

这里我们将鸭子的飞行和呱呱叫行为委托给了 FlyBehavior 和 QuackBehavior 进行处理, 我们采用的是组合(Composition). 这种做法和"继承"不同的地方在于, 鸭子的行为不是继承来的, 而是和适当的行为对象组合来的. 这里我们采用的是第三个设计原则:

**多用组合, 少用继承**.

## 总结

这就是策略模式(Strategy Pattern)定义了算法族, 分别封装起来, 让他们之间可以相互替换, 此模式让算法的变化独立于使用算法的客户.

OO 基础:

1. 抽象
2. 封装
3. 多态
4. 继承

OO 原则:

1. 封装变化
2. 多用组合, 少用继承
3. 针对接口编程, 不针对实现编程

OO 模式:

1. 策略模式.

要点:

1. 知道 OO 基础, 并不足以让我们设计出良好的 OO 系统.
2. 良好的 OO 设计必须具备可复用, 可扩充, 可维护三个特性.
3. 模式可以让我们建造出具有良好 OO 设计质量的系统.
4. 模式被认为是历经验证的 OO 设计经验.
5. 模式不是代码, 而是针对设计问题的通用解决方案.
6. 模式不是被发明, 而是被发现.
7. 大多数的模式着眼于软件变化.
8. 我们通常把系统中变化的部分封装起来.
9. 模式让开发人员之间有共享语言, 能够最大化沟通的价值
