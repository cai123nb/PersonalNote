# Java 内存区域与内存溢出异常

## 概述

Java 和 C 之间有一堵由内存动态分配和垃圾收集技术所围成的"高墙", 墙里面的人想出去, 墙外面的人想进去.
对于 C 和 C++, 开发人员在内存管理区域, 必须为每一个对象生命开始到终结负担所有的责任. 而对于 Java 来说, 在 Java 虚拟机自动内存管理机制的帮助下, 不在需要为每一个 new 操作去写配对的 delete/free 操作, 不容易出现内存泄漏, 这一切看起来很完美. 但是一旦出现内存泄漏和溢出方面的问题, 如果你不了解虚拟机的工作, 那么错误将会成为一项异常艰难的工作.

## 运行时的数据区域

Java 虚拟机在执行 Java 程序的过程中会把它所管理的内存划分为若干个不同的数据区域.

![show](https://image.cjyong.com/blog/jvm/3.jpg)

### 程序计数器(Program Counter Register)

程序计数器是一块较小的内存区域, 记录着当前代码执行的位置(行号). 在虚拟机的概念模型中(仅仅是概念模型), 字节码解释器工作时就是通过改变计数器的值来选取下一条要执行的字节码指令. 如分支, 循环, 跳转, 异常处理, 线程恢复等基础功能都需要依赖程序计数器.

由于 Java 中的多线程是通过线程轮流切换并分配处理器执行时间来实现的, 在任何一个时刻, 一个处理只会处理一条线程中的指令. 所以为了线程切换后可以恢复到正确的执行位置, 每条线程需要一个独立的程序计数器, 互不影响, 独立存储.

> 我们称这种内存区域为`线程私有(线程隔离)`的内存区域. 其生命周期和线程相同.

如果线程正在执行的是一个 Java 方法, 那么程序计数器中存储的是正在执行的 Java 虚拟机字节码指令的地址, 如果执行的是 Native 方法, 这个计数器值则有空(Underfined). 此内存区域是 Java 虚拟机中唯一一个没有规定任何 OutOfMemeoryError 情况的区域.

### Java 虚拟机栈 (Java Virtual Machine Stacks)

我们常说的 Java 堆内存 Heap 和栈内存 Stack, 其中栈内存(Stack)一般指的就是 Java 虚拟机栈, 更确切的说应该指的是 Java 虚拟机栈中局部变量表部分. 和程序计数器类似, Java 虚拟机栈也是`线程私有(线程隔离)`的, 生命周期与线程相同. Java 虚拟机栈描述的是 Java 方法执行的内存模型, 每个方法执行时都会产生一个`栈帧(Stack Frame)`, `栈帧(Stack Frame)`存储着局部变量表, 操作数栈, 动态链接, 方法出口等信息. 每一个方法就调用过程, 就对应着一个`栈帧`在 Java 虚拟机栈中入栈和出栈. 如我们调用一个方法, 方法开始调用就会产生一个新的栈帧放入 Java 虚拟机栈, 调用结束了, 就代表着当前方法的`栈帧`移出 Java 虚拟机栈.

> 在`栈帧`局部变量表中, 64 位长度的 long 和 double 类型的数据会占用 2 个局部变量空间(Slot), 其余类型的数据只占用 1 个. 局部变量表的空间大小在编译区间就已经确定和分配好了, 在运行时是不会进行改变大小的.Java

Java 虚拟机在这块内存区域定义了两种异常状况: 如果线程请求的栈深度大于虚拟机所允许的深度, 将会抛出 StackOverflowError 异常.如果虚拟机栈动态拓展, 拓展时无法申请到足够的内存, 就会抛出 OutOfMemoryError 异常.

> StackOverflowError: 常见于递归方法的调用, 由于每次递归(先暂时不考虑尾调)都是在当前方法中调用自身, 导致当前栈帧无法移出虚拟机栈, 只好在当前栈帧中在申请一个栈帧存放新的递归方法,类似如此一直递归下去, 如果递归的深度超过了虚拟机所允许的深度就会抛出异常.

### 本地方法栈

与 Java 虚拟机栈类似, 只不过 Java 虚拟机栈执行的是 Java 方法, 而本地方法栈则为 Native 方法. 由于功能类似, 有些虚拟机将二者合二为一(如 HotSpot 虚拟机). 同样会抛出 StackOverFlowError 和 OutOfMemoryError 异常.

### Java 堆(Java Heap)

对大多数的 Java 应用来说, Java 堆是 Java 虚拟机中所管理的内存中最大的一块. Java 堆是所有线程共享的一块内存区域, 用于存放所有的对象实例, 几乎所有的对象实例都在这里进行分配内存. 因此 Java 堆也是垃圾收集器管理的主要区域, 很多时候也被称为`GC堆(Garbage Collected Heap)`. 从内存回收的角度来看, 由于现在收集器基本都采用分代收集算法, 所以 Java 堆还可以细分为新生代和老年代, 再细化一点, Eden 空间, From Survivor 空间, To Survivor 空间等.详细内存下节在详讲.

根据 Jav 虚拟机的规范, Java 堆可以处于物理上不连续的内存空间, 只要逻辑上是连续的即可, 类似我们的磁盘空间一样. 实现的时候, 一般都是可拓展的(通过-Xmx 和-Xms 控制), 如果堆中没有内存完成实例分配, 并且堆也无法拓展时,就会抛出 OutOfMemeoryError 异常.

### 方法区(Method Area)

对于 HotSpot 虚拟机来说, Method Area 相当于`永久代(Permanent Generation)`, 本质上两者不相同, 只不过 HotSpot 将 GC 分代收集拓展到了方法区, 这样就可以偷懒不用单独为方法区写垃圾收集的代码了. 对于其他虚拟机如 J9, JRockit 是不存在`永久代`这个区域的. 由于`永久代`这个区域存在-XX:MaxPermSize 的上限, 很容易出现内存溢出的问题.

> Java 虚拟机规范对方法区的限制非常宽松, 除了不需要连续内存和大小可拓展以外, 还可以选择不实现垃圾收集.

根据虚拟机规范, 如果当方法区无法满足内存分配需求时, 抛出 OutOfMemoryError 异常.

### 运行时常量池(Runtime Constant Pool)

运行时常量池时方法区的一部分. Class 文件除了有类的版本, 字段, 方法, 接口等描述信息外, 还有一项信息是常量池(Const Pool Table), 用于存放编译期生成的各种字面量和符号引用, 这部分内容在类加载后, 就会放入运行时常量池.
Java 虚拟机对运行时常量池没有做任何细节的规定, 因此相对于 Class 文件常量池, 它具有动态性: 我们不仅可以在编译期预先放置常量, 我们同样可以在运行时添加常量, 如 String 的 intern 方法. 同理, 由于属于方法区的一部分, 如果当运行常量池无法满足内存分配需求时, 抛出 OutOfMemoryError 异常.

### 直接内存(Direct Memory)

直接内存不是虚拟机运行的数据区的一部分, 也不是虚拟机规范中定义的内存区域. 但是这部分内存也被频繁使用, 可能出现 OutOfMemoryError 异常出现.
在 JDK1.4 之后, JDK 添加 NIO 类, 引入一种基于通道(Channel)和缓冲区(Buffer)的 I/O 方式, 它可以使用 Native 函数库方法, 直接分配堆外内存, 然后通过存储在 Java 堆中的 DirectByteBuffer 对象作为这个内存的引用进行操作. 这在一些场景中可以显著提高性能, 避免了在 Java 堆和 Native 堆中来回复制数据.
本机直接内存不受 Java 堆的限制, 但是还是受到本机总内存大小和处理器寻址空间的限制. 服务器管理员在配置虚拟机参数时, 有时候忘记了直接内存, 就会使得各个内存区域总和大于物理内存限制, 导致 OutOfMemoryError 异常.

## HotSpot 虚拟机对象探秘

### 对象的创建

在语言层面上, 创建对象(如克隆, 反序列化)通常仅仅是一个 new 关键字, 但是在虚拟机中对象的创建往往更为复杂:

1. 虚拟机遇到一条 new 指令时, 首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用, 并且检查这个符号引用代表的类是否被加载, 解析和初始化过. 如果没有就必须先执行对应的类加载过程.
2. 类加载检查通过之后, 虚拟机将为新生对象分配内存. 对象的内存的大小在类加载完成后便可以完全确定, 为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来.

   > 如果 Java 堆中内存是绝对规整的, 所有用的内存都放在一边, 空闲的内存放在另一边, 中间放着一个指针作为分界点的指示器, 那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离, 这种分配方式称为`指针碰撞(Bump the Pointer`. 如果 Java 堆中的内存不是规整的, 已使用内存和空闲的内存相互交错, 就没有办法简单地进行`指针碰撞`, 虚拟机必须维护一个列表, 记录上那些内存块时时可用的, 在分配的时候从列表中找到一块足够大的空间划分给对象实例, 并更新列表上的记录, 这种分配方式称为`空闲列表(Free List)`. 选择那种分配方式由 Java 堆是否规整决定, 而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定. 因此, 在使用 Seria, ParNew 等带 Compact 过程的收集器时, 系统采用的就是`指针碰撞`, 而使用 CMS 这种基于 Mark-Sweep 算法的收集器时, 通常采用的是`空闲列表`.
   > 对象创建在虚拟机中是非常频繁的行为, 即使是仅仅修改一个指针所指向的位置, 在并发情况下也不是线程安全的, 如虚拟机正在给对象 A 分配内存, 指针还没来得及修改, 对象 B 又开始同时使用原来的指针来分配内存. 解决这种问题有两个解决方案: 一种是对分配内存空间的动作进行同步处理, 实际上虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性; 另外一种是把内存分配的动作按照线程划分在不同的空间之中进行, 及每个线程在 Java 堆中预先分配一小块内存, 称为本地线程分配缓冲(Thread Local Allocation Buffer, TLAB). 那个线程要分配内存, 就在那个线程的 TLAB 上分配. 只有 TLAB 用完并分配新的 TLAB 时, 才需要同步锁定. 可以通过-XX:+/- UseTLAB 参数来设定.

3. 内存分配完毕之后, 虚拟机需要将分配到的内存空间都初始化为零值(不包括对象头), 如果使用 TLAB, 这一工作过程可以提前到 TLAB 分配时候进行. 这个步骤保证了 Java 代码可以通过不赋初值就可以直接使用.
4. 虚拟机需要对对象进行必要的设置, 如这个对象是哪个类的实例, 如何才能找到类的元数据信息, 对象的哈希码, 对象的 GC 分代年龄等信息. 这些信息存储在对象头(Object Header)之中.
5. 在虚拟机视角, 到这一步, 对象已经产生, 单纯 Java 程序的视角来看, 对象才刚刚开始, init 方法还没有执行. 执行 new 指令之后, 会接着执行 init 方法, 把对象按照程序员的意愿进行初始化, 这样一个真正的可用对象才算完全产生出来了.

### 对象的内存布局

在 HotSpot 虚拟机中, 对象在内存中存储的布局可以分为 3 块区域: 对象头(Header), 实例数据(Instance Data) 和对齐填充(Padding).

#### 对象头

包括两部分信息, 第一部分用于存储对象自身的运行时的数据, 如 HashCode, GC 分代年龄, 锁状态标志, 线程持有的锁, 偏向线程 ID, 偏向时间戳. 这部分数据在长度为 32 位和 64 位的虚拟机(未开启压缩指针) 中分别为 32 位, 64 位, 官方称为`Mark Word`. 对象需要存储的运行时数据很多, 其实已经超过了 32 位, 64 位 Bitmap 结构所能记录的限度, 但是对象头信息是与对象自身定义的数据无关的额外的存储成本, 考虑到虚拟机的空间效率, Mark Word 被设计成一个非固定的数据结构以便在极小的空间内存储尽量多的信息, 它会根据对象的状态复用自己的存储空间.
另一部分就是类型指针, 即对象指向它的类元数据的指针, 虚拟机通过这个指针来确定这个对象是哪个类的实例, 并不是所有的虚拟机实现都必须在对象数据上保留类型指针, 换句话说, 查找对象的元数据信息并不一定要经过对象本身. 另外如果对象是一个 Java 数组, 那么对象头还必须有一块用于记录数组长度的数据, 因为虚拟机可以通过普通的 Java 对象的元数据信息确定 Java 对象的大小, 但是从数组的元数据中却无法确定数组的大小.

#### 实例数据

实例数据是对象真正存储的有效信息, 也是程序代码中所定义的各种类型的字段内容, 无论是从父类继承下来的, 还是在子类中定义的, 都需要记录起来. 这部分的存储顺序受到虚拟机分配策略参数(FieldsAllocationStyle)和字段在 Java 源代码中定义顺序的影响. HotSpot 虚拟机默认的分配策略为: longs/doubles, ints, shorts/chars, bytes/booleans, oops(Ordinary Object Pointers), 我们可以看出, 相同宽度的字段总是被分配到一起. 在满足这个前提条件的情况下, 在父类定义的变量会出现在子类之前. 如果 ComactFields 参数值为 true(默认为 true), 那么子类之中较窄的变量也可能插入到父类变量的空隙中.

#### 对齐填充

对齐填充不是必然存在的, 也没有特别的含义, 仅仅起着占位符的作用. 由于 HotSpot VM 的自动内存管理系统要求对象起始地址必须是 8 字节的整数倍, 换句话说, 就是对象的大小必须是 8 字节的整数倍. 而对象头部分正好是 8 字节的倍数, 因此, 对象实例数据部分没有对齐时, 就需要通过对齐填充来补全.

### 对象的访问定位

建立对象是为了使用对象, Java 程序需要通过栈上的 reference 数据来操作堆上的具体对象. 由于 Reference 类型在 Java 虚拟机规范中只定义了一个指向对象的引用, 没有定义 reference 的实现. 目前主流的访问方式有使用句柄和直接指针两种:
使用句柄访问: 那么 Java 堆中将会划分出一块内存作为句柄池, reference 中存储的对象就是对象的句柄地址, 而句柄中包含了对象实例数据和类型数据各自的地址信息.
![show](https://image.cjyong.com/blog/jvm/4.jpg)

> reference 中存储的是稳定的句柄地址, 如果对象移动(垃圾收集时, 移动对象是非常普遍的行为)只会改变句柄中的实例数据类型指针, 而 reference 本身不需要进行修改.

直接指针访问: Java 堆对象布局中就必须考虑如何放置访问类型数据的相关信息, 而 reference 中存储的直接就是对象地址.
![show](https://image.cjyong.com/blog/jvm/5.jpg)

> 速度更快, 节省了一次指针定位的时间开销. HotSpot 使用就是这种类似的方式.
