# 垃圾收集器与内存分配策略

## 概述

从上一章介绍我们可以知道, Java内存运行时区域的各个部分, 其中程序计数器,虚拟机栈,本地方法栈3个区域随线程而生, 随线程而灭. 栈中的栈帧随着方法的进入和退出而有条不紊地执行出栈和入栈操作. 每个栈帧中分配多少内存基本上是在类结构确定下来时就已知的, 因此这几个区域的内存分配和回收都具备确定性. 不需要考虑回收的问题. 应为方法结束或线程结束时, 内存自然就跟着回收了. 而Java堆和方法区则不一样, 一个借口中多个实现类所需要的内存可能不一样, 一个方法的多个分支需要的内存也可能不一样, 我们只有在程序处于运行期间才能知道会创建那些对象, 这部分内存是动态的, 垃圾收集器所关注的也是这部分内存.

## 对象死了吗

在堆里面存放着Java世界中几乎所有的对象实例, 而垃圾收集器在对堆进行回收时, 首先需要确定的就是有哪些对象还`存活`着, 有哪些对象已经`死了`.

### 引用计数算法

很普遍的一种做法是: 引用计数法, 给一个对象添加一个引用计数器, 每当这个对象被一个地方引用, 计数器加一, 引用失效时, 计数器减一. 当计数器值为0时, 表示这个对象不被引用了.(死了)
优点是实现较为简单, 效率也较高. 存在问题就是: 无法解决循环引用的问题: 如对象A中有对B的引用, 对象B中有对A的引用, 当我们将A和B删除, 不在使用. A和B都无法被回收, 因为A和B都存在引用.

### 可达性分析算法

在主流的商用程序语言(Java, C#, Lisp)的主流实现都是通过`可达性分析(ReachabilityAnalysis)`来判断对象是否存活. 基本思想: 通过一系列的称为`GC Roots`的对象作为起始点, 从这些节点开始向下搜索, 搜索所走过的路径称为`引用链(Reference Chain)`. 当一个对象到GC Roots没有任何引用链相连时(即GC Roots到这个对象不可达), 则证明这个对象是不可用的.
在Java中, 可作为GC Roots的对象有:
+ 虚拟机栈(本地变量表)中引用的对象
+ 方法区中类静态属性引用的对象.
+ 方法区中常量引用的对象.
+ 本地方法栈JNI(一般来说的Native方法)应用的对象.

### 引用的定义

无论是通过引用计数器判断对象的引用数量, 还是通过可达性分析算法判断对象引用链是否可达, 判断对象是否`存活`都与`引用`有关. 在JDK1.2之前, Java中引用的定义很传统: 如果reference类型数据中存储的数值代表的是另外一块内存的存储地址, 就称这块内存代表一个引用. 这种定义很纯粹, 也太狭隘了. 如果我们对一些引用, "食之无味, 弃之可惜", 就显得无能为力, 就像缓存系统一样, 我们希望他实现这样的功能: 当内存还足够时, 则保存在内存空间中, 如果内存空间在进行垃圾收集后还是非常紧张, 则可以抛弃这些对象.
在JDK1.2之后, Java对应用引用的概念进行了拓展, 分为: 强引用(Strong Reference), 软引用(Soft Reference), 弱引用(Weak Reference), 虚引用(Phantom Reference). 强度逐步降低.
+ 强引用: Strong Reference, 类似`Object obj = new Object()`, 平时代码中普遍存在的. 只要强引用还存在, 垃圾收集器永远不会回收掉被引用的对象.
+ 软引用: Soft Reference, 描述一些有用但并非必需的对象. 在系统将要发生内存溢出异常之前, 将会把这些对象进行回收, 如果这次回收后还没有足够的内存, 才会抛出内存溢出异常. Java使用SoftReference类来实现软引用.
+ 弱引用: Week Reference, 描述非必需对象, 强度比Soft Reference弱一些, 被弱引用关联的对象只能生存到下一次垃圾收集发生之前. 当垃圾收集器工作, 无论当前内存是否足够, 都会回收掉只被弱引用关联的对象. Java中提供WeakReference类来实现弱引用.
+ 虚引用: Phantom Reference, 最弱的一种引用, 一个对象无论是否存在虚引用, 完全不会对其生存时间构成影响, 也无法通过虚引用取得一个对象的实例. 设置虚引用的唯一目的就是能在对象被收集器回收时收到一个系统通知. Java中提供PhantomReference类来实现虚引用.

### 生存还是死亡

即使是在可达性分析算法中不可达的对象, 也并非是非死不可, 这时候的它们处于`缓刑`状态, 要真正宣告一个对象死亡, 至少需要经历两次标记过程:
1) 可达性分析后发现没有与GC Roots相连接的引用链, 进行标记. 筛选: 这个对象是否需要执行finalize()方法? 需要执行, 不需要直接收集内存(死了). 判断的条件: 是否重载finaliz()方法? 没有重载, 不需要执行. 重载了: 是否已经执行过了? 执行过了: 不需要执行, 没有执行过: 执行.
2) 如果需要执行Finalize()方法, 将对象放置到一个F-Queue的队列中去, 并在稍后由一个虚拟机自动建立的, 低优先级Finalizer线程去`执行`它.

> 这里的`执行`, 指虚拟机会触发这个方法, 但并不承诺会等该它运行结束, 这样做是预防如果在finalize()方法中执行时, 如果一个对象在finalize()方法中执行缓慢, 或者发生死循环, 将会很可能导致F-Queue队列中其他对象处于等待, 甚至导致整个内存系统崩溃.

finalize()方法时对象逃脱死亡的最后一次机会, 如果对象要在finalize()方法中拯救自己, 需要将自己赋值给某个类的变量或者成员变量, 那么在第二次标记时, 它将移除出`即将回收`的集合.

简单的例子:

```java
package com.cjyong.jvm.gc;

public class FinalizeEscapeGC {
    public static FinalizeEscapeGC SAVE_HOOK = null;

    public void isAlive(){
        System.out.println("Yes, I am still alive:)");
    }

    @Override
    protected void finalize() throws Throwable {
        super.finalize();
        System.out.println("Finalize method executed!");
        FinalizeEscapeGC.SAVE_HOOK = this;
    }

    public static void main(String[] args) throws Throwable{
        SAVE_HOOK = new FinalizeEscapeGC();

        //对象第一次成功拯救自己
        SAVE_HOOK = null;
        System.gc();
        //Finalize方法优先级很低, 所以暂停0.5秒以等待
        Thread.sleep(500);
        if (SAVE_HOOK != null) {
            SAVE_HOOK.isAlive();
        } else {
            System.out.println("no, i am dead: :(");
        }

        SAVE_HOOK = null;
        System.gc();
        //Finalize方法优先级很低, 所以暂停0.5秒以等待
        Thread.sleep(500);
        if (SAVE_HOOK != null) {
            SAVE_HOOK.isAlive();
        } else {
            System.out.println("no, i am dead: :(");
        }
    }
}
```

![show](https://image.cjyong.com/blog/jvm/1.png)

> finalize()函数并不是C/C++中的析构函数, 它的诞生只是在Java刚开始出生的时候为了让C/C++程序员更好地接受, 而设计的. 它的运行代价高昂, 就有很大的不确定性, 无法保证各个对象的调用顺序. 不建议我们使用.

### 回收方法区

方法区(HotSpot中的永久代)进行垃圾收集的效率极低, 主要收集两部分的内容: 废弃常量和无用类
回收废弃常量比较简单, 类似堆, 当没有其他引用这个常量, 如果这时发生垃圾回收, 这时候就会将该常量清除出常量池.
无用类: 回收较为复杂, 需要满足以下3个条件,
1. 该类所有的实例都已经被回收, 也就是Java堆中不存在该类的任何实例.
2. 加载该类的ClassLoaer已经被回收.
3. 该类对应的Javalcang.Class对象没有在任何地方被引用, 无法再任何地方通过反射访问该类的方法.
虚拟机可以对满足了上述3个条件的无用类进行回收, 这里说的也仅仅是`可以`, 并不是一定会回收. HotSpot虚拟机提供-Xnoclassgc参数加于控制, 还可以使用-verbose:class以及-XX:TraceClassLoadint(可以在Product版虚拟机中使用), -XX:TraceClassUnLoading(需要FastDebug版虚拟机中才可以使用)查看类加载和卸载信息.

## 垃圾收集算法

由于垃圾算法的实现涉及大量程序细节, 而且各个平台的虚拟机操作内存的方法各不相同, 这里只是简单介绍几种算法的思想和其发展过程.

### 标记-清除算法

最基础的收集算法就是`标记-清除`算法, 如同名字一样, 算法分为两部分, `标记`和`清除`两个阶段, 首先标记出所有需要回收的对象, 在标记完成后统一回收所有的对象. 它主要的不足分为以下两点:
+ 效率问题: 标记和清除的效率都不高.
+ 空间问题: 标记清除之后会产生大量不连续的内存碎片, 空间碎片大多可能导致以后在程序运行过程中需要分配较大的对象时, 无法找到足够的连续的内存而不得不提前出发另一次垃圾收集动作.

> 后续的算法都是基于解决这一算法的不足而产生的

### 复制算法

为了解决`效率`的问题, `复制`算法出现了, 它将可用内存平均分为两部分, 每次只使用其中一块. 当一块内存使用完了的时候, 就将还存活的对象复制到另一块上面, 然后再把已使用过的内存空间一次清理掉. 这样使得每次都是对整个半区进行内存回收, 内存分配时也就不用考虑内存碎片等复杂情况, 只需要移动堆顶指针, 按顺序分配内存就可以了, 实现简单, 运行高效. 但是代价就将内存缩小为原来的一半, 有些高昂.
现在的商业虚拟机都采用这种收集算法来回收新生代, IBM公司专门研究表明新生代中的对象98%是朝生夕死, 所以并不需要按照1:1的比例来划分内存空间区域, 而是将内存划分为一块较大的Eden空间和两块较小的Survivor空间, 每次使用Edn空间和一块Survivor空间. 每当要回收的时候, 就将还存活的对象一次性的拷贝到另一块Survivor空间上, 最后清理掉Eden和刚才用过的Survivor空间. HotSpot虚拟机中默认Eden和Survivor的比例为8:1. 也就是每次新生代最后存活下来大概只有10%, 但是如果在某次回收中, 存活的数量很多, 超过了10%, 这时候一个Survivor空间就不够使用了, 这时候就需要依赖别的内存(这里指的是老年代)`进行分配担保`.

> `分配担保`: 就像银行贷款一样, 如果我们的信誉很好, 每次都能按时按量的偿还, 于是银行就会默认我们下一次也能按时按量地偿还, 这时候只需要一个担保人能保证如果我不能按时还款, 可以从他的账户里扣钱, 那银行就会认为这没有风险.

内存分配也一样, 如果一块Survivor空间没有足够的内存存放上一次新生代收集下来的存活对象, 就采用`分配担保`的方法进入老年区.

### 标记 - 整理算法

复制收集算法在对象存活率较高的时候就要进行较多的复制操作, 效率会变得很低. 老年代的存活率一般较高, 一般不采用这种算法. 根据老年代的特点, 有人设计出来一种`标记-整理(Mark-Compact)`算法, 标记过程与`标记-清除`算法一样, 但后续步骤部署直接对可回收对象进行整理, 而是让所有存活的对象都向一端移动, 然后直接清理掉端边界以外的内存.

### 分代收集算法

当前商业虚拟机, 都采用`分代收集`算法, 只是根据对象存活的不同将区域划分为新生代和老年代, 这样就可以根据各年代的特点采用最适当的收集算法. 在新生代中, 我们每次垃圾收集时都会发现大批对象死去, 少量存活, 那就采用复制算法. 对于老年代中对象存活率高, 没有额外空间进行分配担保, 采用`标记-清除`或者`标记-整理`算法进行处理.

## HotSpot算法实现

### 枚举根节点

从可达性分析中从GC Roots节点找引用链这个操作为例, 可作为GC Roots的节点主要在全局性引用(常量或类静态属性)与执行上下文(栈帧中本地变量表)中, 现在很多应用仅仅方法区就有数百兆, 如果要逐个检查里面的引用, 那么必然要消耗很多时间.
另外, 可达性分析对执行时间的敏感性还体现在GC停顿上, 因为这项工作必须在一个能确保一致性的快照中进行, 这里的一致性指的是在整个分析期间整个执行系统看起来就像被冻结在某个时间点上, 不可以出现分析过程中对象引用关系还在变化的情况, 该点不满足的话分析结果准确性就无法得到保障. 这点是导致GC进行时, 必须停顿所有的Java执行线程(Sun将这件事称为"Stop The World")的其中一个重要原因.
由于目前的主流Java虚拟机使用的都是准确式GC, 所以当执行系统停顿下来后, 并不需要一个不漏地检查完所有执行上下文和全局的引用位置, 虚拟机应当是有办法直接得知那些地方存放着对象引用. 在HotSpot的实现中, 是采用一组称为OopMap的数据结构来达到这个目的的, 在类加载完成的时候, HotSpot就把对象内什么偏移量上是什么类型的数据计算出来, 在JIT编译过程中, 也会在特定位置记录下栈和寄存器中那些位置是引用.

### 安全点

在OopMap的协助下, HotSpot可以快速且准确地完成GC Roots枚举, 但这出现一个很现实的问题: OopMap内容变化的指令非常多, 如果为每一条指令都产生OopMap, 那将需要大量的额外空间, 这样GC的空间成本将会变得很高. 实际上HostSpot也的确没有为每条指令都生成OopMap, 只是在`特定位置`记录了这些信息, 这些位置称为安全点(Safepoint), 即程序执行时并非在所有地方都能停顿下来开始GC, 只有在到达安全点时才能暂停. Safepoint的选定不能过于频繁以致于过分增大运行时的负荷. 所以, 安全点的选定基本上是以程序"是否具有让程序长时间执行的特征"为标准选定的, 因为每条指令的执行时间都非常短暂, 所以程序不太可能因为指令流长度太长这个原因而过长时间运行, "长时间执行"的最明显特征就是指令序列复用, 例如方法调用, 循环跳转, 异常跳转等. 所以具有这些功能的指令才会产生Safepoint.
对于Safepoint, 另外一个需要考虑的问题是如何在GC发生时让所有的线程(这里不包括JNI调用的线程)都"跑"到最近的安全点上在停顿下来. 这里有两种方案可供选择: 抢先式中断(Preemptive Suspension)和主动式中断(Voluntary Suspension). 抢先式中断: 不需要线程的执行代码主动配合, 在GC发生时, 首先把所有线程全部中断, 如果发现有线程中断的地方不在安全点, 就恢复线程, 让它跑到线程安全点上. 但是几乎没有虚拟机的实现采用该种方法. 主动式中断: 当GC需要中断线程的时候, 不直接对线程操作, 仅仅的设置一个标志, 各个线程执行到安全点时, 自动轮询这个标志, 如果该标志被设置了就会触发线程中断.

### 安全区域

使用Safepoint似乎已经完美地解决了如何进入GC的问题, 但实际情况却并不一定. Safepoint保证了程序执行时, 在不太长的时间内就会遇到可进入GC的Safepoint. 但是, 程序"不执行"的时候呢, 就是程序没有分配CPU时间, 如线程处于Sleep状态或者Blocked状态, 这时候线程无法响应JVM的中断请求, "走"到安全的地方去中断挂起, JVM也显然不太可能等待线程重新被分配CPU时间. 对于这种情况, 就需要安全区域(Safe Region)来解决.
安全区域就是指在一段代码片段之中, 引用关系不会发生变化. 在这个区域中任意地方开始GC都是安全的. 我们也可以把Safe Region看做是被拓展了的Safepoint.
当线程执行到Safe Region中的代码时, 首先标记自己已经进入到Safe Region, 那样当在这段时间里JVM要发起GC时, 就不用管标识自己为Safe Region状态的线程了. 当线程要离开Safe Region时, 它要检查系统是否已经完成了根节点枚举(或者GC过程), 如果完成了, 那么线程就继续执行, 否则它就必须等待直到收到可以安全离开Safe Region的信号为止.

## 垃圾收集器

如果说收集算法是内存回收的方法论, 那么垃圾收集器就是内存回收的具体实现. Java虚拟机规范中对垃圾收集器应该如何实现没有明确的规定, 因此不同的厂商, 不同版本的虚拟机所提供的垃圾收集器都可能会有很大的差别, 并且一般都会听参数供用户根据指的应用特点和要求组合出各个年代所使用的收集器. JDK1.7Update14之后的HotSpot虚拟机中所包含的收集器如下:

![show](https://image.cjyong.com/blog/jvm/6.jpg)

图片按照年代进行分类, 如果两个收集器之间有连接线, 说明二者可以搭配使用. 这里详细讲解一下各个收集器的特点.

### Serial收集器

Serial收集器时最基本, 发展历史最悠久的收集器, 曾经(JDK1.3.1之前)是虚拟机新生代收集的唯一选择. Serial收集器(Serial翻译为串行)是一个单线程的收集器, 但它的`单线程`不仅仅是只会使用一个CPU或一条收集线程去完成垃圾收集工作, 更重要的是它在进行垃圾收集时, 必须暂停其他所有的工作线程, 直到它收集结束. Just like it called `Stop The World`. 正如我们通常的想法, 当你妈妈给你打扫荡房间的时候, 肯定也会让你老老实实地在椅子上或者外面待着, 如果她一边打扫, 你一边乱扔纸屑, 那怎么能清扫完.
从JDK1.3开始, 到现在的JDK1.7, HotSpot虚拟机开发团队一直都在为消除或者减少工作线程因内存回收而导致停顿而努力. 但是Serial也有自己的优点: 简单高效. 对于限定的单个CPU的环境来说, Serial收集器由于没有线程交互的开销, 专心做垃圾收集自然可以获得最高的单线程收集效率. 在用户的桌面应用场景中, 分配给虚拟机管理的内存一般不会很大, 收集几十兆甚至一两百兆的新生代, 停顿时间完全可以控制哎几十毫秒最多一百多毫秒以内, 只要不是频繁发生, 这是可以接受的. Serial收集器对于运行在Client模式下的虚拟机来说是一个很好的选择.

### ParNew收集器

ParNew收集器其实就是Serial收集器的多线程版本(也是新生代的垃圾收集器), 除了使用多条线程进行垃圾收集之外, 其余的行为包括Serial收集器可用控制参数(例如: -XX:SurvivorRatio, -XX:PretenureSizeThreshold等), 收集算法, Stop The World, 对象分配规则等等与Serial收集器完全一样, 在实现上两者也公用了大多数的代码.
ParNew收集器除了多线程收集之外, 其他和Serial收集器相比没有太多的创新之处, 但它却是许多运行在Server模式下虚拟中首选的新生代收集器, 这里面有一个很大的非性能原因: 除了Serial收集器之外, 只有ParNew收集器可以和CMS收集器(老年代收集器)配合工作. 而CMS收集器(老年代的主流收集器)自JDK1.5开始, 真正意义上实现了并发(Concurrent)收集器, 可以让垃圾收集线程和用户线程同时工作, 用上面的例子来说就是: 做到了你妈妈一边打扫房间的时候, 你还能一边扔垃圾.
ParNew收集器在单CPU的环境下, 绝对不会比Serial收集器有更好的效果, 甚至由于线程之间交互的开销, 收集器都不能在2个CPU的环境下100%超过Serial收集器. 但是随着CPU的增加, 它对于GC是系统资源的有效利用还是很有好处的. 它默认开启的线程数和CPU的数量相同, 如果CPU数量过多, 可以使用-XX: ParallelGCThreads参数进行设置.

### Parallel Scanvenge收集器

Parallel Scanvengage收集器时新生代收集器, 它也是使用复制算法的收集器, 也是并行的多线程收集器, 看上去和ParNew都一样, 那它有什么有特别之处?
Parallel Scavenge收集器的特点是它的关注点和其他收集器不同, CMS等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间, 而Parallel Scanvenge收集器的目的是则是达到一个可控制的吞吐量(Throughput). 所谓的吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值, 即吞吐量 = 运行用户代码的时间 / (运行用户代码的时间 + 垃圾收集时间), 如虚拟机总共运行了100分钟, 其中垃圾收集花掉了1分钟, 那吞吐量就是99%.
停顿时间越短就越适合与用户交互的程序, 良好的响应速度可以提升用户体验, 而高吞吐量则可以高效率地利用CPU时间, 尽快完成程序的运算任务, 主要适合在后台运算而不需要太多交互的任务.
Parallel Scanvenge收集器提供了两个参数用于准确控制吞吐量, 分别是控制最大垃圾收集停顿时间-XX:MaxGCPauseMillis参数以及直接设置吞吐量大小的参数-XX:GCTimeRatio参数.
MaxGCPauseMillis参数允许设置的值是一个大于0的参数, 收集器将尽可能地保证内存回收的所花费的时间不超过设定值. 这里存在一个误解, 就是如果我们设置这个值越小越好. 这是不对的想法, 如果我们设置的这个值非常小, 那么收集器将牺牲吞吐量和新生代空间来换取: 系统将新生代调小一些, 那么收集的垃圾就少了很多, 就会快一点. 但是这样, 垃圾收集的频率也高了, 吞吐量就不一定会降下来.
GCTimeRatio参数是一个大于0且小于100的整数, 也就是垃圾收集时间占总时间的比率, 相当于吞吐量的倒数. 如果我们将这个值设置成19, 那么GC时间占据5%(即1 / (1 + 19)),默认值是99, 就是允许最大1%.(即1 / (1 + 99))的垃圾收集时间.
除了Parallel Scanvenge收集器称为"吞吐量优先"收集器之外, Parallel Scavenge收集器还有一个很大的特点: 自适应调节. Parallel Scavenge收集器还有一个参数-XX:+UseAdaptiveSizePolicy, 这是一个开关参数, 如果我们打开了这个参数, 我们不需要手动设置新生代大小, Eden和Survivor区的比例, 晋升老年代对象大小等细节参数, 虚拟机会自动根据当前系统运行情况收集性能监控信息, 动态调整参数以提供最合适的停顿时间或最大吞吐量, 这种调节方式称为GC自适应调节策略(GC Ergonomics).

### Serial Old收集器

Serial Old是Serial收集器的老年代版本, 它同样是一个单线程收集器, 使用`标记-整理`算法, 主要用于Client模式下虚拟机使用. 如果在Server模式下, 它还有两大用途: 一种用途是在JDK1.5以及之前的版本中与Parallel Scanvenge收集器搭配使用, 另一个就是作为CMS收集器的后备预案, 在并发收集发生Concurrent Mode Failure时使用.

### Parallel Old收集器

Parallel Old是Parallel Scanvenge收集器的老年代版本, 使用多线程和`标记-整理`算法. 这个收集器在JDK1.6才开始提供, 在此之前, 新生代的Parallel Scavenge收集器一直处于很尴尬的位置: 如果你新生代选择了Parallel Scavenge收集器, 老年代除了Serial Old收集器没有别的选择了. 由于老年代的Serial Old收集器在服务端性能的`拖累`, 这种组合很多时候不如ParNew + CMS组合给力.
Parallel Old收集器出来之后, `吞吐量优先`的收集器终于可以有了自己的组合方式: Parallel Scanvenge + Parallel Old. 在注重吞吐量和CPU资源敏感的场合, 都可以考虑使用这个组合.

### CMS收集器

CMS(Concurrent Mark Sweep)收集器是一种以获取最短回收停顿时间为目标的收集器. 目前很大一部分Java应用集中在互联网或者B/S系统的服务端上, 这类应用尤其重视服务的响应速度, 希望系统的停顿时间最短, 以给用户带来较好的体验.
CMS的工作过程主要分为以下4个步骤:
1. 初始化标记(CMS Initial mark)
2. 并发标记(CMS concurrent mark)
3. 重新标记(CMS remark)
4. 并发清除(CMS concurrent sweep)

初始化标记和重新标记这两个步骤需要`Stop The World`, 初始化标记仅仅是标记以下GC Roots可以直接关联到的对象, 速度很快. 并发标记就是进行GCRoots Tracing的过程, 而重新标记阶段则是为了修正在并发标记期间因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录, 这个阶段一般会比初始标记阶段长一些, 但是远比并发标记时间短. 由于整个过程中耗时最长的并发标记和并发清除过程在收集器线程都可以与用户线程一起工作, 所以, 从总体来说, CMS收集器的内存回收过程是与用户线程一起并发执行的.
主要的优点有: 并发收集, 低停顿. 但是也有3个明显的缺点:
1. CMS收集器对CPU资源非常敏感. 在并发阶段, 会因为占据了一部分线程而导致应用程序变慢, 总吞吐量降低. CMS默认启动的回收线程为(CPU数量 + 3) / 4, 也就是当CPU在4个以上的时候, 并发回收的垃圾收集线程不少于25%的CPU资源.
2. 无法处理浮动垃圾(Floating Garbage), 可能出现"Concurrent Mode Failure"失败而导致另一次Full GC的产生. 由于CMS并发清除阶段, 用户线程还在运行, 这时候还有可能产生新的垃圾, 这部分的垃圾没办法在本次GC过程中进行处理. 这部分垃圾就被称为`浮动垃圾`. 并且由于垃圾收集阶段用户线程还需要运行, 那么不能像其他收集器那样等老年代几乎填满之后再进行收集, 需要预留一部分空间提供并发收集时程序的运作使用. 在JDK1.5默认设置汇总, CMS收集器当老年代使用了68%的空间之后就会激活, 这是一个偏保守的设置, 可以通过设置-XX:CMSInitiatingOccupancyFraction的值来进行设置. 在JDK1.6中该值已经提升至92%. 在CMS运行区间, 如果内存无法满足程序需要, 就会出现一次`Concurrent Mode Failure`失败, 这时虚拟机将启动后备预案: 临时启用Serial Old收集器来重新对老年代进行垃圾收集, 这时候就要停顿一段时间了.
3. CMS是基于`标记-清除`算法来实现的, 这就意味着收集结束会产生大量的空间碎片, 这会给大对象分配带来很大的麻烦, 往往老年代的空间还有很多剩余, 由于没办法找到连续的空间给大对象分配, 不得不触发一次Full GC. 为了解决这个问题, CMS收集器提供了一个-XX: +UseCMSCompactAtFullCollection开关参数(默认开启), 用户CMS收集器顶不住要进行内存碎片的合并整理过程, 内存整理过程没办法并发执行的, 等待时间也较长. 还有一个解决方法, 就是使用-XX:CMSFullGCsBeforeCompaction参数, 这个设置执行多少次不压缩的FullGC后, 就必须要进行一次压缩的FullGC(碎片整理, 默认是0次, 即每次都进行碎片整理).

### G1收集器

G1(Garbage-First)收集器是当今收集器技术发展的最前沿成果之一, 在JDK 7u4中首次发布. G1是一款面向服务端应用的垃圾收集器. HotSpot开发团队赋予它的使命是替换掉CMS收集器. G1具有如下特点:
1. **并行与并发**: GI可以充分利用多CPU, 多核环境下的硬件优势, 使用多个CPU来缩短Stop-The-World的停顿时间, 部分其他收集器原本需要停顿Java线程执行的GC动作, G1收集器仍然可以通过并发的方式让Java程序继续执行.
2. **分代收集**: 与其他收集器一样, 分代的概念在G1中依然可以保留. 虽然G1可以不需要其他收集器配合就能独立管理整个GC堆, 但它能够采用不同的方式去处理新创建的对象和已经存活了一段时间, 熬过了多次GC的旧对象以获得更好的收集效果.
3. **空间整合**: 与CMS的`标记-清理`算法不同, G1从整体来看是基于`标记-整理`算法实现的收集器, 从局部(两个Region之间)上来看是基于`复制`算法实现的, 但无论如何, 这两种算法都意味着G1运行区间不会产生内存空间碎片.
4. **可预测的停顿**: 这是G1相对CMS的另一大优势,降低停顿时间是G1和CMS共同的关注点, 但G1除了追求低停顿外, 还能建立可预测的停顿时间模型, 可以让使用者明确指定在一个长度为M毫秒的时间片段内, 消耗垃圾收集上的时间不得超过N毫秒, 这几乎已经是实时Java(RTSJ)的垃圾收集器的特征了.

之前的收集器收集的范围都是新生代或者老年代, 而G1是面对整个GC堆的. 使用G1收集器时, Java堆的内存布局就和别的收集器有很大区别, 它将整个Java堆划分为多个大小相等的独立区域, 虽然还保留有新生代和老年代的概念, 但是新生代和老生代不再是物理隔离的了, 它们都是一部分Region的集合.
这时候就会出现一个问题: 在G1中垃圾处理是以Region为单位进行的, 但是Region是不可能独立的, 一个对象分配给该Region, 它并非就只有本Region的引用, 而是可以与整个Java堆任意对象发生引用关系. 那么在做可达性判断时, 岂不是还需要扫描整个Java堆才能保证准确性? 这样效率岂不是很低. 这个问题不仅仅是G1会出现, 之前的收集器也有类似的问题. 在G1收集器中, Region中间的对象引用以及其他收集器中的新生代和老年代之间的对象引用, 虚拟机都是采用Remembered Set来避免全堆扫描的. G1中的每个Region都有一个与之对应的Remembered Set, 虚拟机发现程序在对Reference类型数据进行写操作时, 会产生一个Write Barrier暂时中断写操作, 检查Reference引用对象是否处于不同的Region之间, 如果是, 便通过CardTable把相关引用信息记录到被引用对象所属的Region的Remebered Set之中. 当进行内存回收的时候, 在GC根节点的枚举范围中加入Remembered Set即可保证不对全堆扫描也不会有遗漏.

如果我们不考虑Remembered Set操作, G1收集器的运作过程大致可以分为以下几个步骤:
1. 初始标记(Initial Marking)
2. 并发标记(Concurrent Marking)
3. 最终标记(Final Marking)
4. 筛选回收(Live Data Counting and Evacuation)

我们会发现与CMS过程非常相似, 第一步初始化标记, 仅仅只是标记GC Roots可以之间关联的对象, 并修改TAMS（Next Top at Mark Start)的值, 让下一阶段程序并发运行时, 可以正确可用的Region中创建对象, 这时需要停顿线程, 但耗时较短. 第二步进行可达性分析, 找出所有存活的对象, 耗时较长, 但可与用户线程并发执行.而最终标记阶段则是为了修正并发标记区间因用户程序继续运作而导致标记发生变动的那一部分标记记录, 虚拟机将这段时间对象变化记录在线程Remeberred Set Logs里面, 最终标记阶段需要把Remebered Set Logs的数据合并到Remembered Set中, 这阶段需要停顿线程, 但是可并行执行. 最后筛选回收阶段首先对各个Region的后手价值和成本进行排序, 根据用户期望的GC停顿时间来指定回收计划.

> G1依旧追求短停顿, 如果你最求吞吐量, G1并不会给你带来特别的好处. 但相信随着G1的发展, G1会成为最终的胜利者.

### 垃圾收集器参数总结

| 参数                             | 描述                                                                                                      |
|:-------------------------------|:--------------------------------------------------------------------------------------------------------|
| UseSerialGC                    | 虚拟机运行在Client模式下的默认值, 打开此开关后, 使用Serial + Serial Old收集器组合进行内存回收                                           |
| UseParNewGC                    | 打开此开关, 使用ParNew + Serial Old的收集器组合进行内存回收                                                                |
| UseConcMarkSweepGC             | 打开此开关后, 使用ParNew + CMS + Serial Old收集器组合进行内存回收, Serial Old收集器作为CMS收集器出现Concurrent Mode Failure失败后的后备收集器 |
| UseParallelGC                  | 虚拟机运行在Server模式下的默认值, 打开此开关后, 使用Parallel + Scavenge + Serial Old(PS MarkSweep)的收集器组合进行内存回收               |
| UseParallelOldGC               | 打开此开关, 使用Parallel Scavenge + Parallel Old的收集器组合进行内存回收                                                   |
| SurvivorRatio                  | 新生代中Eden区域和Survivor区域的容量比值, 默认为8, 即Eden : Survivor = 8 : 1                                              |
| PretenureSizeThreshold         | 直接晋升老年代的对象大小, 设置这个参数之后, 如果大于这个参数的对象将直接在老年代进行分配                                                          |
| MaxTenURingThreshold           | 晋升到老年代的对象年龄, 每个对象在坚持过一次Minor GC之后, 年龄加1, 当超过这个参数时, 对象进入老年代                                              |
| UseAdaptiveSizePolicy          | 动态调整Java堆中各个区域的大小以及进入老年代的年龄                                                                             |
| HandlerPromotionFailure        | 是否允许担保失败, 即老年代剩余空间不足以应对新生代的整个Eden和Survivor区所有对象都存活的极端情况                                                 |
| ParallelGCThreads              | 设置并行GC时, 进行内存回收的线程数                                                                                     |
| GCTimeRatio                    | GC时间占总时间的比例, 默认值99, 即允许1%的GC时间. 仅仅在Parallel Scavenge收集器时生效                                              |
| MaxGCPauseMillis               | 设置GC的最大停顿时间, 仅仅在使用Parallel Scanvenge收集器时有效                                                              |
| CMSInitiatingOccupancyFraction | 设置CMS收集器在老年代空间被使用多少后, 触发垃圾收集. 默认68%, 仅仅在使用CMS收集器时生效                                                     |
| UseCMSCompactAtFullCollection  | 设置CMS收集器在完成垃圾收集后是否要进行一次内存碎片整理, 仅在使用CMS收集器时生效                                                            |
| CMSFullGCsBeforeCompaction     | 设置CMS收集器在进行若干次垃圾收集后再启动一次碎片整理. 仅在使用CMS收集器时生效                                                             |

## 内存分配与回收策略

Java技术体系中所提倡的自动内存管理最终可以自动化地解决了两个问题: 给对象分配内存和回收分配给对象的内存. 上面大篇幅都是讲解内存回收, 这里探讨一下对象分配内存那些事:

### 对象优先在Eden区域分配

在大多数的情况下, 对象在新生代Eden区中进行分配, 当Eden区没有足够的空间进行分配时,虚拟机直接发起一次MinorGC.

> Minor GC: 新生代GC, 指发生在新生代的垃圾收集动作, 因为Java对象大多是朝生夕灭, 所以Minor GC非常频繁, 回收速度也较快.
> Major GC/Full GC : 老年代GC, 出现了Major GC, 经常会伴随至少一次的Minor GC(但并非绝对), Major GC的速度一般会比Minor GC慢10倍以上.

测试代码:

```java
    private static final int _1MB = 1024 * 1024;
    /**
     * VM参数1: -verbose: -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8
     * //设置Heap大小为20M, 其中10M分配给新生区, Eden区域和Survivor区域比例为: 8 : 1.
     *
     */
    public static void main(String[] args) {
        byte[] allocation1, allocation2, allocation3, allocation4;
        allocation1 = new byte[2 * _1MB];
        allocation2 = new byte[2 * _1MB];
        allocation3 = new byte[2 * _1MB];
        allocation4 = new byte[4 * _1MB];
        //当第四块区域分配内存的时候, 发现Eden区剩余空间不够,进行一次MinorGC,
        // 进行GC之后发现还是不够, 只好通过分配担保机制进入老年区
    }
}
```

输出截图:

![ShowResult](https://image.cjyong.com/blog/jvm/2.png)

截图也可以印证内容, 当前截图可以看出默认使用的是Parallel Scavenge + Parallel Old收集器组合(JDK1.8), 后面代码使用使用Serial + Serial Old进行测验证(添加-XX:+UseSerialGC 参数)

### 大对象直接进入老年代

我们可以通过设置PretenureSizeThreshold参数来控制直接进入老年区对象的带下. 测试代码:

```java
/**
 * VM参数2: -verbose: -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8
 *   -XX:PretenureSizeThreshold=3145728
 * //设置Heap大小为20M, 其中10M分配给新生区, Eden区域和Survivor区域比例为: 8 : 1,
 * 设置晋升老年区大小为3M
 *
 */
public static void main(String[] args) {
    byte[] allocation;
    allocation = new byte[4 * _1MB];
}
```

实验结果截图:

![ShowResult](https://image.cjyong.com/blog/jvm/3.png)

### 长期存活对象将进入老年区

虽然虚拟机采用了分代收集的思想来管理内存, 那么内存回收时就必须能识别哪些对象放在新生代, 哪些对象放在老年代中. 为了实现这一点, 虚拟机给每个对象定义了一个Age计数器, 如果对象在Eden出生并经过第一次Minor GC后仍然存活, 并且可以被Survivor容纳的话, 就将被移动到Survivor空间中, 并且对象年龄设为1. 对象在Survivor区中每`熬过`一次MinorGC, 年龄就增加1岁,当它的年龄增加到一定程度(默认是15岁), 就将晋升老年代. 对象晋升老年代的年龄阈值, 可以通过参数-XX:MaxRenuringThreshold设置.
代码测试:

```java
public class MinorGCTest2 {
    private static final int _1MB = 1024 * 1024;

    /**
     * VM参数: -verbose: -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8
     * -XX:MaxTenuringThreshold=1 -XX:+PrintTenuringDistribution
     */
    @SuppressWarnings("unused")
    public static void main(String[] args) {
        byte[] allocation1, allocation2, allocation3;
        allocation1 = new byte[_1MB / 4]; //用于测试长期存活对象
        allocation2 = new byte[4 * _1MB];
        allocation3 = new byte[4 * _1MB];
        allocation3 = null;
        allocation3 = new byte[4 * _1MB];
    }
}
```

### 动态对象年龄判定

为了可以更好地适应不同程序的内存状况, 虚拟机并不是永远要求对象的年龄必须达到MaxTenuringThreshold才能晋升老年代, 如果在Survivor空间中相同年龄所有对象大小总和大于Survivor空间的一般, 年龄大于或者等于该对象就可以直接进入老年代, 无须等到MaxTenuringThreshold所要求的年龄.

### 空间分配担保

在发生MinorGC之前, 虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象的总空间, 如果这个条件成立, 那么MinorGC可以确保是安全的. 如果不成立, 虚拟机则会查看HandlePromotionFailure设置值是否允许担保失败, 如果允许, 那么会继续坚持老年代最大可用连续空间是否大于历次晋升到老年代对象的平均大小, 如果大于, 将尝试进行一次MinorGC, 尽管这次Minor GC是有风险的. 如果小于, 或者HandlerPromitionFailure设置为不冒险, 那这时将会由MinorGC改为Full GC.

```C
bool TenuredGeneration::promotion_attempt_is_safe(size _t max_promotion_in_bytes) cost {
	//老年代最大可用连续空间
    size_t available = max_contiguous_available();
    //每次晋升到老年代的平均大小
    size_t av_promo = (size_t) gc_status() -> avg_promoted() -> padded_average();
    //老年代可用空间是否大于平均晋升大小, 或者老年代可用空间大于当此GC时新生代所有对象容量
    bool res = (available >= av_promo ) || (available >= max_promotion_inbytes);
    return res;
}
```

