# 垃圾收集器与内存分配策略

## 概述

从上一章介绍我们可以知道, Java 内存运行时区域的各个部分, 其中程序计数器,虚拟机栈,本地方法栈 3 个区域随线程而生, 随线程而灭. 栈中的栈帧随着方法的进入和退出而有条不紊地执行出栈和入栈操作. 每个栈帧中分配多少内存基本上是在类结构确定下来时就已知的, 因此这几个区域的内存分配和回收都具备确定性. 不需要考虑回收的问题. 应为方法结束或线程结束时, 内存自然就跟着回收了. 而 Java 堆和方法区则不一样, 一个借口中多个实现类所需要的内存可能不一样, 一个方法的多个分支需要的内存也可能不一样, 我们只有在程序处于运行期间才能知道会创建那些对象, 这部分内存是动态的, 垃圾收集器所关注的也是这部分内存.

## 对象死了吗

在堆里面存放着 Java 世界中几乎所有的对象实例, 而垃圾收集器在对堆进行回收时, 首先需要确定的就是有哪些对象还`存活`着, 有哪些对象已经`死了`.

### 引用计数算法

很普遍的一种做法是: 引用计数法, 给一个对象添加一个引用计数器, 每当这个对象被一个地方引用, 计数器加一, 引用失效时, 计数器减一. 当计数器值为 0 时, 表示这个对象不被引用了.(死了)
优点是实现较为简单, 效率也较高. 存在问题就是: 无法解决循环引用的问题: 如对象 A 中有对 B 的引用, 对象 B 中有对 A 的引用, 当我们将 A 和 B 删除, 不在使用. A 和 B 都无法被回收, 因为 A 和 B 都存在引用.

### 可达性分析算法

在主流的商用程序语言(Java, C#, Lisp)的主流实现都是通过`可达性分析(ReachabilityAnalysis)`来判断对象是否存活. 基本思想: 通过一系列的称为`GC Roots`的对象作为起始点, 从这些节点开始向下搜索, 搜索所走过的路径称为`引用链(Reference Chain)`. 当一个对象到 GC Roots 没有任何引用链相连时(即 GC Roots 到这个对象不可达), 则证明这个对象是不可用的.
在 Java 中, 可作为 GC Roots 的对象有:

- 虚拟机栈(本地变量表)中引用的对象
- 方法区中类静态属性引用的对象.
- 方法区中常量引用的对象.
- 本地方法栈 JNI(一般来说的 Native 方法)应用的对象.

### 引用的定义

无论是通过引用计数器判断对象的引用数量, 还是通过可达性分析算法判断对象引用链是否可达, 判断对象是否`存活`都与`引用`有关. 在 JDK1.2 之前, Java 中引用的定义很传统: 如果 reference 类型数据中存储的数值代表的是另外一块内存的存储地址, 就称这块内存代表一个引用. 这种定义很纯粹, 也太狭隘了. 如果我们对一些引用, "食之无味, 弃之可惜", 就显得无能为力, 就像缓存系统一样, 我们希望他实现这样的功能: 当内存还足够时, 则保存在内存空间中, 如果内存空间在进行垃圾收集后还是非常紧张, 则可以抛弃这些对象.
在 JDK1.2 之后, Java 对应用引用的概念进行了拓展, 分为: 强引用(Strong Reference), 软引用(Soft Reference), 弱引用(Weak Reference), 虚引用(Phantom Reference). 强度逐步降低.

- 强引用: Strong Reference, 类似`Object obj = new Object()`, 平时代码中普遍存在的. 只要强引用还存在, 垃圾收集器永远不会回收掉被引用的对象.
- 软引用: Soft Reference, 描述一些有用但并非必需的对象. 在系统将要发生内存溢出异常之前, 将会把这些对象进行回收, 如果这次回收后还没有足够的内存, 才会抛出内存溢出异常. Java 使用 SoftReference 类来实现软引用.
- 弱引用: Week Reference, 描述非必需对象, 强度比 Soft Reference 弱一些, 被弱引用关联的对象只能生存到下一次垃圾收集发生之前. 当垃圾收集器工作, 无论当前内存是否足够, 都会回收掉只被弱引用关联的对象. Java 中提供 WeakReference 类来实现弱引用.
- 虚引用: Phantom Reference, 最弱的一种引用, 一个对象无论是否存在虚引用, 完全不会对其生存时间构成影响, 也无法通过虚引用取得一个对象的实例. 设置虚引用的唯一目的就是能在对象被收集器回收时收到一个系统通知. Java 中提供 PhantomReference 类来实现虚引用.

### 生存还是死亡

即使是在可达性分析算法中不可达的对象, 也并非是非死不可, 这时候的它们处于`缓刑`状态, 要真正宣告一个对象死亡, 至少需要经历两次标记过程:

1. 可达性分析后发现没有与 GC Roots 相连接的引用链, 进行标记. 筛选: 这个对象是否需要执行 finalize()方法? 需要执行, 不需要直接收集内存(死了). 判断的条件: 是否重载 finaliz()方法? 没有重载, 不需要执行. 重载了: 是否已经执行过了? 执行过了: 不需要执行, 没有执行过: 执行.
2. 如果需要执行 Finalize()方法, 将对象放置到一个 F-Queue 的队列中去, 并在稍后由一个虚拟机自动建立的, 低优先级 Finalizer 线程去`执行`它.

> 这里的`执行`, 指虚拟机会触发这个方法, 但并不承诺会等该它运行结束, 这样做是预防如果在 finalize()方法中执行时, 如果一个对象在 finalize()方法中执行缓慢, 或者发生死循环, 将会很可能导致 F-Queue 队列中其他对象处于等待, 甚至导致整个内存系统崩溃.

finalize()方法时对象逃脱死亡的最后一次机会, 如果对象要在 finalize()方法中拯救自己, 需要将自己赋值给某个类的变量或者成员变量, 那么在第二次标记时, 它将移除出`即将回收`的集合.

简单的例子:

```java
package com.cjyong.jvm.gc;

public class FinalizeEscapeGC {
    public static FinalizeEscapeGC SAVE_HOOK = null;

    public void isAlive(){
        System.out.println("Yes, I am still alive:)");
    }

    @Override
    protected void finalize() throws Throwable {
        super.finalize();
        System.out.println("Finalize method executed!");
        FinalizeEscapeGC.SAVE_HOOK = this;
    }

    public static void main(String[] args) throws Throwable{
        SAVE_HOOK = new FinalizeEscapeGC();

        //对象第一次成功拯救自己
        SAVE_HOOK = null;
        System.gc();
        //Finalize方法优先级很低, 所以暂停0.5秒以等待
        Thread.sleep(500);
        if (SAVE_HOOK != null) {
            SAVE_HOOK.isAlive();
        } else {
            System.out.println("no, i am dead: :(");
        }

        SAVE_HOOK = null;
        System.gc();
        //Finalize方法优先级很低, 所以暂停0.5秒以等待
        Thread.sleep(500);
        if (SAVE_HOOK != null) {
            SAVE_HOOK.isAlive();
        } else {
            System.out.println("no, i am dead: :(");
        }
    }
}
```

![show](https://image.cjyong.com/blog/jvm/1.png)

> finalize()函数并不是 C/C++中的析构函数, 它的诞生只是在 Java 刚开始出生的时候为了让 C/C++程序员更好地接受, 而设计的. 它的运行代价高昂, 就有很大的不确定性, 无法保证各个对象的调用顺序. 不建议我们使用.

### 回收方法区

方法区(HotSpot 中的永久代)进行垃圾收集的效率极低, 主要收集两部分的内容: 废弃常量和无用类
回收废弃常量比较简单, 类似堆, 当没有其他引用这个常量, 如果这时发生垃圾回收, 这时候就会将该常量清除出常量池.
无用类: 回收较为复杂, 需要满足以下 3 个条件,

1. 该类所有的实例都已经被回收, 也就是 Java 堆中不存在该类的任何实例.
2. 加载该类的 ClassLoaer 已经被回收.
3. 该类对应的 Javalcang.Class 对象没有在任何地方被引用, 无法再任何地方通过反射访问该类的方法.
   虚拟机可以对满足了上述 3 个条件的无用类进行回收, 这里说的也仅仅是`可以`, 并不是一定会回收. HotSpot 虚拟机提供-Xnoclassgc 参数加于控制, 还可以使用-verbose:class 以及-XX:TraceClassLoadint(可以在 Product 版虚拟机中使用), -XX:TraceClassUnLoading(需要 FastDebug 版虚拟机中才可以使用)查看类加载和卸载信息.

## 垃圾收集算法

由于垃圾算法的实现涉及大量程序细节, 而且各个平台的虚拟机操作内存的方法各不相同, 这里只是简单介绍几种算法的思想和其发展过程.

### 标记-清除算法

最基础的收集算法就是`标记-清除`算法, 如同名字一样, 算法分为两部分, `标记`和`清除`两个阶段, 首先标记出所有需要回收的对象, 在标记完成后统一回收所有的对象. 它主要的不足分为以下两点:

- 效率问题: 标记和清除的效率都不高.
- 空间问题: 标记清除之后会产生大量不连续的内存碎片, 空间碎片大多可能导致以后在程序运行过程中需要分配较大的对象时, 无法找到足够的连续的内存而不得不提前出发另一次垃圾收集动作.

> 后续的算法都是基于解决这一算法的不足而产生的

### 复制算法

为了解决`效率`的问题, `复制`算法出现了, 它将可用内存平均分为两部分, 每次只使用其中一块. 当一块内存使用完了的时候, 就将还存活的对象复制到另一块上面, 然后再把已使用过的内存空间一次清理掉. 这样使得每次都是对整个半区进行内存回收, 内存分配时也就不用考虑内存碎片等复杂情况, 只需要移动堆顶指针, 按顺序分配内存就可以了, 实现简单, 运行高效. 但是代价就将内存缩小为原来的一半, 有些高昂.
现在的商业虚拟机都采用这种收集算法来回收新生代, IBM 公司专门研究表明新生代中的对象 98%是朝生夕死, 所以并不需要按照 1:1 的比例来划分内存空间区域, 而是将内存划分为一块较大的 Eden 空间和两块较小的 Survivor 空间, 每次使用 Edn 空间和一块 Survivor 空间. 每当要回收的时候, 就将还存活的对象一次性的拷贝到另一块 Survivor 空间上, 最后清理掉 Eden 和刚才用过的 Survivor 空间. HotSpot 虚拟机中默认 Eden 和 Survivor 的比例为 8:1. 也就是每次新生代最后存活下来大概只有 10%, 但是如果在某次回收中, 存活的数量很多, 超过了 10%, 这时候一个 Survivor 空间就不够使用了, 这时候就需要依赖别的内存(这里指的是老年代)`进行分配担保`.

> `分配担保`: 就像银行贷款一样, 如果我们的信誉很好, 每次都能按时按量的偿还, 于是银行就会默认我们下一次也能按时按量地偿还, 这时候只需要一个担保人能保证如果我不能按时还款, 可以从他的账户里扣钱, 那银行就会认为这没有风险.

内存分配也一样, 如果一块 Survivor 空间没有足够的内存存放上一次新生代收集下来的存活对象, 就采用`分配担保`的方法进入老年区.

### 标记 - 整理算法

复制收集算法在对象存活率较高的时候就要进行较多的复制操作, 效率会变得很低. 老年代的存活率一般较高, 一般不采用这种算法. 根据老年代的特点, 有人设计出来一种`标记-整理(Mark-Compact)`算法, 标记过程与`标记-清除`算法一样, 但后续步骤部署直接对可回收对象进行整理, 而是让所有存活的对象都向一端移动, 然后直接清理掉端边界以外的内存.

### 分代收集算法

当前商业虚拟机, 都采用`分代收集`算法, 只是根据对象存活的不同将区域划分为新生代和老年代, 这样就可以根据各年代的特点采用最适当的收集算法. 在新生代中, 我们每次垃圾收集时都会发现大批对象死去, 少量存活, 那就采用复制算法. 对于老年代中对象存活率高, 没有额外空间进行分配担保, 采用`标记-清除`或者`标记-整理`算法进行处理.

## HotSpot 算法实现

### 枚举根节点

从可达性分析中从 GC Roots 节点找引用链这个操作为例, 可作为 GC Roots 的节点主要在全局性引用(常量或类静态属性)与执行上下文(栈帧中本地变量表)中, 现在很多应用仅仅方法区就有数百兆, 如果要逐个检查里面的引用, 那么必然要消耗很多时间.
另外, 可达性分析对执行时间的敏感性还体现在 GC 停顿上, 因为这项工作必须在一个能确保一致性的快照中进行, 这里的一致性指的是在整个分析期间整个执行系统看起来就像被冻结在某个时间点上, 不可以出现分析过程中对象引用关系还在变化的情况, 该点不满足的话分析结果准确性就无法得到保障. 这点是导致 GC 进行时, 必须停顿所有的 Java 执行线程(Sun 将这件事称为"Stop The World")的其中一个重要原因.
由于目前的主流 Java 虚拟机使用的都是准确式 GC, 所以当执行系统停顿下来后, 并不需要一个不漏地检查完所有执行上下文和全局的引用位置, 虚拟机应当是有办法直接得知那些地方存放着对象引用. 在 HotSpot 的实现中, 是采用一组称为 OopMap 的数据结构来达到这个目的的, 在类加载完成的时候, HotSpot 就把对象内什么偏移量上是什么类型的数据计算出来, 在 JIT 编译过程中, 也会在特定位置记录下栈和寄存器中那些位置是引用.

### 安全点

在 OopMap 的协助下, HotSpot 可以快速且准确地完成 GC Roots 枚举, 但这出现一个很现实的问题: OopMap 内容变化的指令非常多, 如果为每一条指令都产生 OopMap, 那将需要大量的额外空间, 这样 GC 的空间成本将会变得很高. 实际上 HostSpot 也的确没有为每条指令都生成 OopMap, 只是在`特定位置`记录了这些信息, 这些位置称为安全点(Safepoint), 即程序执行时并非在所有地方都能停顿下来开始 GC, 只有在到达安全点时才能暂停. Safepoint 的选定不能过于频繁以致于过分增大运行时的负荷. 所以, 安全点的选定基本上是以程序"是否具有让程序长时间执行的特征"为标准选定的, 因为每条指令的执行时间都非常短暂, 所以程序不太可能因为指令流长度太长这个原因而过长时间运行, "长时间执行"的最明显特征就是指令序列复用, 例如方法调用, 循环跳转, 异常跳转等. 所以具有这些功能的指令才会产生 Safepoint.
对于 Safepoint, 另外一个需要考虑的问题是如何在 GC 发生时让所有的线程(这里不包括 JNI 调用的线程)都"跑"到最近的安全点上在停顿下来. 这里有两种方案可供选择: 抢先式中断(Preemptive Suspension)和主动式中断(Voluntary Suspension). 抢先式中断: 不需要线程的执行代码主动配合, 在 GC 发生时, 首先把所有线程全部中断, 如果发现有线程中断的地方不在安全点, 就恢复线程, 让它跑到线程安全点上. 但是几乎没有虚拟机的实现采用该种方法. 主动式中断: 当 GC 需要中断线程的时候, 不直接对线程操作, 仅仅的设置一个标志, 各个线程执行到安全点时, 自动轮询这个标志, 如果该标志被设置了就会触发线程中断.

### 安全区域

使用 Safepoint 似乎已经完美地解决了如何进入 GC 的问题, 但实际情况却并不一定. Safepoint 保证了程序执行时, 在不太长的时间内就会遇到可进入 GC 的 Safepoint. 但是, 程序"不执行"的时候呢, 就是程序没有分配 CPU 时间, 如线程处于 Sleep 状态或者 Blocked 状态, 这时候线程无法响应 JVM 的中断请求, "走"到安全的地方去中断挂起, JVM 也显然不太可能等待线程重新被分配 CPU 时间. 对于这种情况, 就需要安全区域(Safe Region)来解决.
安全区域就是指在一段代码片段之中, 引用关系不会发生变化. 在这个区域中任意地方开始 GC 都是安全的. 我们也可以把 Safe Region 看做是被拓展了的 Safepoint.
当线程执行到 Safe Region 中的代码时, 首先标记自己已经进入到 Safe Region, 那样当在这段时间里 JVM 要发起 GC 时, 就不用管标识自己为 Safe Region 状态的线程了. 当线程要离开 Safe Region 时, 它要检查系统是否已经完成了根节点枚举(或者 GC 过程), 如果完成了, 那么线程就继续执行, 否则它就必须等待直到收到可以安全离开 Safe Region 的信号为止.

## 垃圾收集器

如果说收集算法是内存回收的方法论, 那么垃圾收集器就是内存回收的具体实现. Java 虚拟机规范中对垃圾收集器应该如何实现没有明确的规定, 因此不同的厂商, 不同版本的虚拟机所提供的垃圾收集器都可能会有很大的差别, 并且一般都会听参数供用户根据指的应用特点和要求组合出各个年代所使用的收集器. JDK1.7Update14 之后的 HotSpot 虚拟机中所包含的收集器如下:

![show](https://image.cjyong.com/blog/jvm/6.jpg)

图片按照年代进行分类, 如果两个收集器之间有连接线, 说明二者可以搭配使用. 这里详细讲解一下各个收集器的特点.

### Serial 收集器

Serial 收集器时最基本, 发展历史最悠久的收集器, 曾经(JDK1.3.1 之前)是虚拟机新生代收集的唯一选择. Serial 收集器(Serial 翻译为串行)是一个单线程的收集器, 但它的`单线程`不仅仅是只会使用一个 CPU 或一条收集线程去完成垃圾收集工作, 更重要的是它在进行垃圾收集时, 必须暂停其他所有的工作线程, 直到它收集结束. Just like it called `Stop The World`. 正如我们通常的想法, 当你妈妈给你打扫荡房间的时候, 肯定也会让你老老实实地在椅子上或者外面待着, 如果她一边打扫, 你一边乱扔纸屑, 那怎么能清扫完.
从 JDK1.3 开始, 到现在的 JDK1.7, HotSpot 虚拟机开发团队一直都在为消除或者减少工作线程因内存回收而导致停顿而努力. 但是 Serial 也有自己的优点: 简单高效. 对于限定的单个 CPU 的环境来说, Serial 收集器由于没有线程交互的开销, 专心做垃圾收集自然可以获得最高的单线程收集效率. 在用户的桌面应用场景中, 分配给虚拟机管理的内存一般不会很大, 收集几十兆甚至一两百兆的新生代, 停顿时间完全可以控制哎几十毫秒最多一百多毫秒以内, 只要不是频繁发生, 这是可以接受的. Serial 收集器对于运行在 Client 模式下的虚拟机来说是一个很好的选择.

### ParNew 收集器

ParNew 收集器其实就是 Serial 收集器的多线程版本(也是新生代的垃圾收集器), 除了使用多条线程进行垃圾收集之外, 其余的行为包括 Serial 收集器可用控制参数(例如: -XX:SurvivorRatio, -XX:PretenureSizeThreshold 等), 收集算法, Stop The World, 对象分配规则等等与 Serial 收集器完全一样, 在实现上两者也公用了大多数的代码.
ParNew 收集器除了多线程收集之外, 其他和 Serial 收集器相比没有太多的创新之处, 但它却是许多运行在 Server 模式下虚拟中首选的新生代收集器, 这里面有一个很大的非性能原因: 除了 Serial 收集器之外, 只有 ParNew 收集器可以和 CMS 收集器(老年代收集器)配合工作. 而 CMS 收集器(老年代的主流收集器)自 JDK1.5 开始, 真正意义上实现了并发(Concurrent)收集器, 可以让垃圾收集线程和用户线程同时工作, 用上面的例子来说就是: 做到了你妈妈一边打扫房间的时候, 你还能一边扔垃圾.
ParNew 收集器在单 CPU 的环境下, 绝对不会比 Serial 收集器有更好的效果, 甚至由于线程之间交互的开销, 收集器都不能在 2 个 CPU 的环境下 100%超过 Serial 收集器. 但是随着 CPU 的增加, 它对于 GC 是系统资源的有效利用还是很有好处的. 它默认开启的线程数和 CPU 的数量相同, 如果 CPU 数量过多, 可以使用-XX: ParallelGCThreads 参数进行设置.

### Parallel Scanvenge 收集器

Parallel Scanvengage 收集器时新生代收集器, 它也是使用复制算法的收集器, 也是并行的多线程收集器, 看上去和 ParNew 都一样, 那它有什么有特别之处?
Parallel Scavenge 收集器的特点是它的关注点和其他收集器不同, CMS 等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间, 而 Parallel Scanvenge 收集器的目的是则是达到一个可控制的吞吐量(Throughput). 所谓的吞吐量就是 CPU 用于运行用户代码的时间与 CPU 总消耗时间的比值, 即吞吐量 = 运行用户代码的时间 / (运行用户代码的时间 + 垃圾收集时间), 如虚拟机总共运行了 100 分钟, 其中垃圾收集花掉了 1 分钟, 那吞吐量就是 99%.
停顿时间越短就越适合与用户交互的程序, 良好的响应速度可以提升用户体验, 而高吞吐量则可以高效率地利用 CPU 时间, 尽快完成程序的运算任务, 主要适合在后台运算而不需要太多交互的任务.
Parallel Scanvenge 收集器提供了两个参数用于准确控制吞吐量, 分别是控制最大垃圾收集停顿时间-XX:MaxGCPauseMillis 参数以及直接设置吞吐量大小的参数-XX:GCTimeRatio 参数.
MaxGCPauseMillis 参数允许设置的值是一个大于 0 的参数, 收集器将尽可能地保证内存回收的所花费的时间不超过设定值. 这里存在一个误解, 就是如果我们设置这个值越小越好. 这是不对的想法, 如果我们设置的这个值非常小, 那么收集器将牺牲吞吐量和新生代空间来换取: 系统将新生代调小一些, 那么收集的垃圾就少了很多, 就会快一点. 但是这样, 垃圾收集的频率也高了, 吞吐量就不一定会降下来.
GCTimeRatio 参数是一个大于 0 且小于 100 的整数, 也就是垃圾收集时间占总时间的比率, 相当于吞吐量的倒数. 如果我们将这个值设置成 19, 那么 GC 时间占据 5%(即 1 / (1 + 19)),默认值是 99, 就是允许最大 1%.(即 1 / (1 + 99))的垃圾收集时间.
除了 Parallel Scanvenge 收集器称为"吞吐量优先"收集器之外, Parallel Scavenge 收集器还有一个很大的特点: 自适应调节. Parallel Scavenge 收集器还有一个参数-XX:+UseAdaptiveSizePolicy, 这是一个开关参数, 如果我们打开了这个参数, 我们不需要手动设置新生代大小, Eden 和 Survivor 区的比例, 晋升老年代对象大小等细节参数, 虚拟机会自动根据当前系统运行情况收集性能监控信息, 动态调整参数以提供最合适的停顿时间或最大吞吐量, 这种调节方式称为 GC 自适应调节策略(GC Ergonomics).

### Serial Old 收集器

Serial Old 是 Serial 收集器的老年代版本, 它同样是一个单线程收集器, 使用`标记-整理`算法, 主要用于 Client 模式下虚拟机使用. 如果在 Server 模式下, 它还有两大用途: 一种用途是在 JDK1.5 以及之前的版本中与 Parallel Scanvenge 收集器搭配使用, 另一个就是作为 CMS 收集器的后备预案, 在并发收集发生 Concurrent Mode Failure 时使用.

### Parallel Old 收集器

Parallel Old 是 Parallel Scanvenge 收集器的老年代版本, 使用多线程和`标记-整理`算法. 这个收集器在 JDK1.6 才开始提供, 在此之前, 新生代的 Parallel Scavenge 收集器一直处于很尴尬的位置: 如果你新生代选择了 Parallel Scavenge 收集器, 老年代除了 Serial Old 收集器没有别的选择了. 由于老年代的 Serial Old 收集器在服务端性能的`拖累`, 这种组合很多时候不如 ParNew + CMS 组合给力.
Parallel Old 收集器出来之后, `吞吐量优先`的收集器终于可以有了自己的组合方式: Parallel Scanvenge + Parallel Old. 在注重吞吐量和 CPU 资源敏感的场合, 都可以考虑使用这个组合.

### CMS 收集器

CMS(Concurrent Mark Sweep)收集器是一种以获取最短回收停顿时间为目标的收集器. 目前很大一部分 Java 应用集中在互联网或者 B/S 系统的服务端上, 这类应用尤其重视服务的响应速度, 希望系统的停顿时间最短, 以给用户带来较好的体验.
CMS 的工作过程主要分为以下 4 个步骤:

1. 初始化标记(CMS Initial mark)
2. 并发标记(CMS concurrent mark)
3. 重新标记(CMS remark)
4. 并发清除(CMS concurrent sweep)

初始化标记和重新标记这两个步骤需要`Stop The World`, 初始化标记仅仅是标记以下 GC Roots 可以直接关联到的对象, 速度很快. 并发标记就是进行 GCRoots Tracing 的过程, 而重新标记阶段则是为了修正在并发标记期间因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录, 这个阶段一般会比初始标记阶段长一些, 但是远比并发标记时间短. 由于整个过程中耗时最长的并发标记和并发清除过程在收集器线程都可以与用户线程一起工作, 所以, 从总体来说, CMS 收集器的内存回收过程是与用户线程一起并发执行的.
主要的优点有: 并发收集, 低停顿. 但是也有 3 个明显的缺点:

1. CMS 收集器对 CPU 资源非常敏感. 在并发阶段, 会因为占据了一部分线程而导致应用程序变慢, 总吞吐量降低. CMS 默认启动的回收线程为(CPU 数量 + 3) / 4, 也就是当 CPU 在 4 个以上的时候, 并发回收的垃圾收集线程不少于 25%的 CPU 资源.
2. 无法处理浮动垃圾(Floating Garbage), 可能出现"Concurrent Mode Failure"失败而导致另一次 Full GC 的产生. 由于 CMS 并发清除阶段, 用户线程还在运行, 这时候还有可能产生新的垃圾, 这部分的垃圾没办法在本次 GC 过程中进行处理. 这部分垃圾就被称为`浮动垃圾`. 并且由于垃圾收集阶段用户线程还需要运行, 那么不能像其他收集器那样等老年代几乎填满之后再进行收集, 需要预留一部分空间提供并发收集时程序的运作使用. 在 JDK1.5 默认设置汇总, CMS 收集器当老年代使用了 68%的空间之后就会激活, 这是一个偏保守的设置, 可以通过设置-XX:CMSInitiatingOccupancyFraction 的值来进行设置. 在 JDK1.6 中该值已经提升至 92%. 在 CMS 运行区间, 如果内存无法满足程序需要, 就会出现一次`Concurrent Mode Failure`失败, 这时虚拟机将启动后备预案: 临时启用 Serial Old 收集器来重新对老年代进行垃圾收集, 这时候就要停顿一段时间了.
3. CMS 是基于`标记-清除`算法来实现的, 这就意味着收集结束会产生大量的空间碎片, 这会给大对象分配带来很大的麻烦, 往往老年代的空间还有很多剩余, 由于没办法找到连续的空间给大对象分配, 不得不触发一次 Full GC. 为了解决这个问题, CMS 收集器提供了一个-XX: +UseCMSCompactAtFullCollection 开关参数(默认开启), 用户 CMS 收集器顶不住要进行内存碎片的合并整理过程, 内存整理过程没办法并发执行的, 等待时间也较长. 还有一个解决方法, 就是使用-XX:CMSFullGCsBeforeCompaction 参数, 这个设置执行多少次不压缩的 FullGC 后, 就必须要进行一次压缩的 FullGC(碎片整理, 默认是 0 次, 即每次都进行碎片整理).

### G1 收集器

G1(Garbage-First)收集器是当今收集器技术发展的最前沿成果之一, 在 JDK 7u4 中首次发布. G1 是一款面向服务端应用的垃圾收集器. HotSpot 开发团队赋予它的使命是替换掉 CMS 收集器. G1 具有如下特点:

1. **并行与并发**: GI 可以充分利用多 CPU, 多核环境下的硬件优势, 使用多个 CPU 来缩短 Stop-The-World 的停顿时间, 部分其他收集器原本需要停顿 Java 线程执行的 GC 动作, G1 收集器仍然可以通过并发的方式让 Java 程序继续执行.
2. **分代收集**: 与其他收集器一样, 分代的概念在 G1 中依然可以保留. 虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆, 但它能够采用不同的方式去处理新创建的对象和已经存活了一段时间, 熬过了多次 GC 的旧对象以获得更好的收集效果.
3. **空间整合**: 与 CMS 的`标记-清理`算法不同, G1 从整体来看是基于`标记-整理`算法实现的收集器, 从局部(两个 Region 之间)上来看是基于`复制`算法实现的, 但无论如何, 这两种算法都意味着 G1 运行区间不会产生内存空间碎片.
4. **可预测的停顿**: 这是 G1 相对 CMS 的另一大优势,降低停顿时间是 G1 和 CMS 共同的关注点, 但 G1 除了追求低停顿外, 还能建立可预测的停顿时间模型, 可以让使用者明确指定在一个长度为 M 毫秒的时间片段内, 消耗垃圾收集上的时间不得超过 N 毫秒, 这几乎已经是实时 Java(RTSJ)的垃圾收集器的特征了.

之前的收集器收集的范围都是新生代或者老年代, 而 G1 是面对整个 GC 堆的. 使用 G1 收集器时, Java 堆的内存布局就和别的收集器有很大区别, 它将整个 Java 堆划分为多个大小相等的独立区域, 虽然还保留有新生代和老年代的概念, 但是新生代和老生代不再是物理隔离的了, 它们都是一部分 Region 的集合.
这时候就会出现一个问题: 在 G1 中垃圾处理是以 Region 为单位进行的, 但是 Region 是不可能独立的, 一个对象分配给该 Region, 它并非就只有本 Region 的引用, 而是可以与整个 Java 堆任意对象发生引用关系. 那么在做可达性判断时, 岂不是还需要扫描整个 Java 堆才能保证准确性? 这样效率岂不是很低. 这个问题不仅仅是 G1 会出现, 之前的收集器也有类似的问题. 在 G1 收集器中, Region 中间的对象引用以及其他收集器中的新生代和老年代之间的对象引用, 虚拟机都是采用 Remembered Set 来避免全堆扫描的. G1 中的每个 Region 都有一个与之对应的 Remembered Set, 虚拟机发现程序在对 Reference 类型数据进行写操作时, 会产生一个 Write Barrier 暂时中断写操作, 检查 Reference 引用对象是否处于不同的 Region 之间, 如果是, 便通过 CardTable 把相关引用信息记录到被引用对象所属的 Region 的 Remebered Set 之中. 当进行内存回收的时候, 在 GC 根节点的枚举范围中加入 Remembered Set 即可保证不对全堆扫描也不会有遗漏.

如果我们不考虑 Remembered Set 操作, G1 收集器的运作过程大致可以分为以下几个步骤:

1. 初始标记(Initial Marking)
2. 并发标记(Concurrent Marking)
3. 最终标记(Final Marking)
4. 筛选回收(Live Data Counting and Evacuation)

我们会发现与 CMS 过程非常相似, 第一步初始化标记, 仅仅只是标记 GC Roots 可以之间关联的对象, 并修改 TAMS（Next Top at Mark Start)的值, 让下一阶段程序并发运行时, 可以正确可用的 Region 中创建对象, 这时需要停顿线程, 但耗时较短. 第二步进行可达性分析, 找出所有存活的对象, 耗时较长, 但可与用户线程并发执行.而最终标记阶段则是为了修正并发标记区间因用户程序继续运作而导致标记发生变动的那一部分标记记录, 虚拟机将这段时间对象变化记录在线程 Remeberred Set Logs 里面, 最终标记阶段需要把 Remebered Set Logs 的数据合并到 Remembered Set 中, 这阶段需要停顿线程, 但是可并行执行. 最后筛选回收阶段首先对各个 Region 的后手价值和成本进行排序, 根据用户期望的 GC 停顿时间来指定回收计划.

> G1 依旧追求短停顿, 如果你最求吞吐量, G1 并不会给你带来特别的好处. 但相信随着 G1 的发展, G1 会成为最终的胜利者.

### 垃圾收集器参数总结

| 参数                           | 描述                                                                                                                                                 |
| :----------------------------- | :--------------------------------------------------------------------------------------------------------------------------------------------------- |
| UseSerialGC                    | 虚拟机运行在 Client 模式下的默认值, 打开此开关后, 使用 Serial + Serial Old 收集器组合进行内存回收                                                    |
| UseParNewGC                    | 打开此开关, 使用 ParNew + Serial Old 的收集器组合进行内存回收                                                                                        |
| UseConcMarkSweepGC             | 打开此开关后, 使用 ParNew + CMS + Serial Old 收集器组合进行内存回收, Serial Old 收集器作为 CMS 收集器出现 Concurrent Mode Failure 失败后的后备收集器 |
| UseParallelGC                  | 虚拟机运行在 Server 模式下的默认值, 打开此开关后, 使用 Parallel + Scavenge + Serial Old(PS MarkSweep)的收集器组合进行内存回收                        |
| UseParallelOldGC               | 打开此开关, 使用 Parallel Scavenge + Parallel Old 的收集器组合进行内存回收                                                                           |
| SurvivorRatio                  | 新生代中 Eden 区域和 Survivor 区域的容量比值, 默认为 8, 即 Eden : Survivor = 8 : 1                                                                   |
| PretenureSizeThreshold         | 直接晋升老年代的对象大小, 设置这个参数之后, 如果大于这个参数的对象将直接在老年代进行分配                                                             |
| MaxTenURingThreshold           | 晋升到老年代的对象年龄, 每个对象在坚持过一次 Minor GC 之后, 年龄加 1, 当超过这个参数时, 对象进入老年代                                               |
| UseAdaptiveSizePolicy          | 动态调整 Java 堆中各个区域的大小以及进入老年代的年龄                                                                                                 |
| HandlerPromotionFailure        | 是否允许担保失败, 即老年代剩余空间不足以应对新生代的整个 Eden 和 Survivor 区所有对象都存活的极端情况                                                 |
| ParallelGCThreads              | 设置并行 GC 时, 进行内存回收的线程数                                                                                                                 |
| GCTimeRatio                    | GC 时间占总时间的比例, 默认值 99, 即允许 1%的 GC 时间. 仅仅在 Parallel Scavenge 收集器时生效                                                         |
| MaxGCPauseMillis               | 设置 GC 的最大停顿时间, 仅仅在使用 Parallel Scanvenge 收集器时有效                                                                                   |
| CMSInitiatingOccupancyFraction | 设置 CMS 收集器在老年代空间被使用多少后, 触发垃圾收集. 默认 68%, 仅仅在使用 CMS 收集器时生效                                                         |
| UseCMSCompactAtFullCollection  | 设置 CMS 收集器在完成垃圾收集后是否要进行一次内存碎片整理, 仅在使用 CMS 收集器时生效                                                                 |
| CMSFullGCsBeforeCompaction     | 设置 CMS 收集器在进行若干次垃圾收集后再启动一次碎片整理. 仅在使用 CMS 收集器时生效                                                                   |

## 内存分配与回收策略

Java 技术体系中所提倡的自动内存管理最终可以自动化地解决了两个问题: 给对象分配内存和回收分配给对象的内存. 上面大篇幅都是讲解内存回收, 这里探讨一下对象分配内存那些事:

### 对象优先在 Eden 区域分配

在大多数的情况下, 对象在新生代 Eden 区中进行分配, 当 Eden 区没有足够的空间进行分配时,虚拟机直接发起一次 MinorGC.

> Minor GC: 新生代 GC, 指发生在新生代的垃圾收集动作, 因为 Java 对象大多是朝生夕灭, 所以 Minor GC 非常频繁, 回收速度也较快.
> Major GC/Full GC : 老年代 GC, 出现了 Major GC, 经常会伴随至少一次的 Minor GC(但并非绝对), Major GC 的速度一般会比 Minor GC 慢 10 倍以上.

测试代码:

```java
    private static final int _1MB = 1024 * 1024;
    /**
     * VM参数1: -verbose: -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8
     * //设置Heap大小为20M, 其中10M分配给新生区, Eden区域和Survivor区域比例为: 8 : 1.
     *
     */
    public static void main(String[] args) {
        byte[] allocation1, allocation2, allocation3, allocation4;
        allocation1 = new byte[2 * _1MB];
        allocation2 = new byte[2 * _1MB];
        allocation3 = new byte[2 * _1MB];
        allocation4 = new byte[4 * _1MB];
        //当第四块区域分配内存的时候, 发现Eden区剩余空间不够,进行一次MinorGC,
        // 进行GC之后发现还是不够, 只好通过分配担保机制进入老年区
    }
}
```

输出截图:

![ShowResult](https://image.cjyong.com/blog/jvm/2.png)

截图也可以印证内容, 当前截图可以看出默认使用的是 Parallel Scavenge + Parallel Old 收集器组合(JDK1.8), 后面代码使用使用 Serial + Serial Old 进行测验证(添加-XX:+UseSerialGC 参数)

### 大对象直接进入老年代

我们可以通过设置 PretenureSizeThreshold 参数来控制直接进入老年区对象的带下. 测试代码:

```java
/**
 * VM参数2: -verbose: -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8
 *   -XX:PretenureSizeThreshold=3145728
 * //设置Heap大小为20M, 其中10M分配给新生区, Eden区域和Survivor区域比例为: 8 : 1,
 * 设置晋升老年区大小为3M
 *
 */
public static void main(String[] args) {
    byte[] allocation;
    allocation = new byte[4 * _1MB];
}
```

实验结果截图:

![ShowResult](https://image.cjyong.com/blog/jvm/3.png)

### 长期存活对象将进入老年区

虽然虚拟机采用了分代收集的思想来管理内存, 那么内存回收时就必须能识别哪些对象放在新生代, 哪些对象放在老年代中. 为了实现这一点, 虚拟机给每个对象定义了一个 Age 计数器, 如果对象在 Eden 出生并经过第一次 Minor GC 后仍然存活, 并且可以被 Survivor 容纳的话, 就将被移动到 Survivor 空间中, 并且对象年龄设为 1. 对象在 Survivor 区中每`熬过`一次 MinorGC, 年龄就增加 1 岁,当它的年龄增加到一定程度(默认是 15 岁), 就将晋升老年代. 对象晋升老年代的年龄阈值, 可以通过参数-XX:MaxRenuringThreshold 设置.
代码测试:

```java
public class MinorGCTest2 {
    private static final int _1MB = 1024 * 1024;

    /**
     * VM参数: -verbose: -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8
     * -XX:MaxTenuringThreshold=1 -XX:+PrintTenuringDistribution
     */
    @SuppressWarnings("unused")
    public static void main(String[] args) {
        byte[] allocation1, allocation2, allocation3;
        allocation1 = new byte[_1MB / 4]; //用于测试长期存活对象
        allocation2 = new byte[4 * _1MB];
        allocation3 = new byte[4 * _1MB];
        allocation3 = null;
        allocation3 = new byte[4 * _1MB];
    }
}
```

### 动态对象年龄判定

为了可以更好地适应不同程序的内存状况, 虚拟机并不是永远要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代, 如果在 Survivor 空间中相同年龄所有对象大小总和大于 Survivor 空间的一般, 年龄大于或者等于该对象就可以直接进入老年代, 无须等到 MaxTenuringThreshold 所要求的年龄.

### 空间分配担保

在发生 MinorGC 之前, 虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象的总空间, 如果这个条件成立, 那么 MinorGC 可以确保是安全的. 如果不成立, 虚拟机则会查看 HandlePromotionFailure 设置值是否允许担保失败, 如果允许, 那么会继续坚持老年代最大可用连续空间是否大于历次晋升到老年代对象的平均大小, 如果大于, 将尝试进行一次 MinorGC, 尽管这次 Minor GC 是有风险的. 如果小于, 或者 HandlerPromitionFailure 设置为不冒险, 那这时将会由 MinorGC 改为 Full GC.

```C
bool TenuredGeneration::promotion_attempt_is_safe(size _t max_promotion_in_bytes) cost {
    //老年代最大可用连续空间
    size_t available = max_contiguous_available();
    //每次晋升到老年代的平均大小
    size_t av_promo = (size_t) gc_status() -> avg_promoted() -> padded_average();
    //老年代可用空间是否大于平均晋升大小, 或者老年代可用空间大于当此GC时新生代所有对象容量
    bool res = (available >= av_promo ) || (available >= max_promotion_inbytes);
    return res;
}
```
