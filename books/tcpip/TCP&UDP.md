# TCP 与 UDP

## 传输层的作用

TCP/IP 中有两个具有代表性的传输层协议, 分别是 TCP 和 UDP. TCP 提供可靠的通信传输, 而 UDP 则常被用于让广播和细节控制交给应用的通信传输.

### 传输层定义

在前面提到过, IP 首部有一个协议字段, 用来表示网络层(IP)的上一层所采用的是哪一种传输层协议. 根据这个字段的协议号, 就可以识别 IP 传输的数据究竟是 TCP 内容还是 UDP 内容.

同样, 传输层的 TCP 和 UDP, 为了识别自己所传输的数据部分究竟应该发给那个应用, 也设定了一个编号. 因为同一个 IP 下可能运行着多个应用, 需要确定是谁进行接收数据. 就如同寄快递, 确定收货地点之外, 我们往往还需要确定收货人(收货地点内往往有很多人). 为了实现这个功能, 使用了端口号这样的识别码. 根据端口号的差异就可以识别传输层上一层的应用层中所需要进行处理的具体程序.

### 通信处理

TCP/IP 的众多应用协议大多以客户端/服务端的形式运行. 客户端类似于客户的意思, 是请求的发起端. 而服务端则提供服务的意思,是请求的处理端.

![show](https://image.cjyong.com/blog/tcpip/120.png)

传输协议 TCP,UDP 通过接收数据中的目标端口号识别目标处理程序.

### 传输层协议 TCP 和 UDP

#### TCP

TCP 是面向连接的,可靠的流协议. 流是指不间断的数据结构, 类比于水管中的水流. TCP 为提供可靠性传输, 实行`顺序控制`或`重发控制`机制. 此外还具备`流控制`,`拥塞控制`,提高网络利用率等众多功能.

#### UDP

UDP 是不具备可靠性的数据报协议. 细微的处理它会上交给上层的应用去完成. 在 UDP 的情况下,虽然可以确保发送消息的大小, 却不能保证消息一定会到达. 因此, 应用有时会根据自己的需要进行重发处理.

### TCP 和 UDP 的区分

TCP 用于在传输层有必要实现可靠传输的情况. 由于它是面向有连接并具备顺序控制, 重发控制等机制的, 所以可以为应用提供可靠的传输.

UDP 则是主要用于那些对高速传输和实时性有较高要求的通信或广播通信. 如我们使用 IP 进行通话, 如果使用 TCP, 数据在传输过程中丢失会被重发, 但这样无法流畅地传输通话人的声音, 会导致无法进行正常交流. 而采用 UDP, 它不会进行重发处理. 从而也就不会有声音大幅度延迟的问题. 即使有部分数据丢失, 也只是只会影响某一个部分的通话. 此外, 在多播与广播通信中也是用 UDP 而不是 TCP. RIP, DHCP 等基于广播的协议也要依赖于 UDP.

## 端口号

### 端口号定义

数据链路和 IP 中的地址, 分别指的是 MAC 地址和 IP 地址. 前者用来识别统一链路上不同的计算机. 后者来识别 TCP/IP 网络中互连的主机和路由器. 在传输层也有这种类似地址的概念, 那就是端口号. 端口号用来识别同一台计算机中进行通信的不同应用程序. 因此, 它也被称为程序地址.

### 根据端口号来识别应用

一台计算机中可以同时运行多个程序, 如 Web 服务, 邮件服务, 远程登录服务等等. 传输层协议就是使用这些端口来识别本机中正在进行通信的应用程序, 并准确地将数据传输.

### 通过 IP 地址+端口号+协议号进行通信识别

仅凭目标端口识别某一个通信是不够的. 在 TCP/UDP 通信中通常使用 5 个信息来识别一个通信: `源IP地址`,`目标IP地址`,`协议号`,`源端口号`,`目标端口号`. 只要其中某一项不同, 则被认为是其他通信.

### 端口号如何确定

在实际通信过程中, 要事先确定端口号. 确定端口号的方法有两种:

#### 标准既定的端口号

为每个应用程序指定其一个固定的端口号. 如 HTTP,TELNET,FTP 等被广泛使用的的应用协议使用的端口号就是固定的. 这些端口号也被称为知名端口号(Well-Known Port Number). 知名端口号一般由 0 到 1023 的数字分配而成. 应用程序应该避免使用知名端口号进行既定目的之外的通信, 以免产生冲突.

#### 时序分配法

服务端有必要确定监听端口号, 但是接受服务的客户端没有必要确定端口号. 在这种方法下, 客户端应用程序没有必要自己设置端口号, 而全权交给操作系统进行分配. 操作系统为每个应用程序分配互不冲突的端口号. 如, 每需要一个新的端口号时 就在之前分配号码的基础上加 1. 这样,操作系统就可以动态管理端口了.

### 端口号与协议

端口号由其使用的传输层协议决定, 因此不同的传输协议可以使用相同的端口号. 如 TCP 和 UDP 使用同一个端口号, 但使用的目的各不相同, 这是因为端口号上的处理是根据每个传输协议的不同而进行的: 数据到达 IP 层的时候, 会检查 IP 首部中的协议号, 再传递给相应的协议的模板. 如果是 TCP 则传给 TCP 模块, 如果是 UDP 则传给 UDP 模块去做端口号的处理. 即使是同一个端口号, 由于传输协议的不同而独自处理, 因此相互之间不会受到影响.

## UDP 通信

UDP 是 User Datagram Protocol 的缩写. UDP 不提供复杂的控制机制,利用 IP 提供面向无连接的通信服务. 并且它是将应用程序发来的数据在收到的那一刻, 立即按照原样发送到网络上的一种机制. 这种方式缺乏灵活性, 如无法进行流量控制, 无法保证传输途中的完整性(如果出现丢包, 不负责进行重发; 如果包顺序发生错误, 也没有纠正功能).

由于 UDP 面向无连接, 随时发送数据, 并且 UDP 本身的处理简单高效, 经常用于以下几个方面:

- 包总量较少通信(DNS,SNMP 等)
- 视频, 音频等多媒体通信(即时通信)
- 限定于 LAN 等特定网络中的应用通信
- 广播通信(广播,多播)

## TCP 通信

UDP 是一种没有复杂控制, 提供面向无连接通信服务的一种协议. 它将部分控制转移给应用程序去处理, 自己只提供作为传输层协议的最基本功能. 而 TCP 则是对`传输,发送,通信`进行控制的协议, 在 IP 中无连接的网络上也能够实现高可靠性的通信.

### TCP 的特点及其目的

为了通过 IP 数据报实现高可靠性传输, 需要考虑很多事情, 如数据破坏, 丢包, 重复以及分片顺序混乱等问题. 而 TCP 通过校验和,序列号, 确认应答, 重发控制, 连接管理以及窗口控制等机制实现可靠性传输.

### 通过序列号与确认应答提高可靠性

在 TCP 中, 当发送端的数据到达接收主机时, 接收端主机会返回一个已收到消息的通知, 这个消息叫做确认应答(ACK).

网络中的确认应答(ACK, Positive Acknowledgement)而类似于对话中对方听懂对话内容时会说:"嗯". 而当对方没有理解对话内容或没有听清时会问一句"咦", 这就好比一个否认确认应答(NACK: Negative Acknowledge).

![show](https://image.cjyong.com/blog/tcpip/121.png)

TCP 通过肯定的确认应答(ACK)实现可靠的数据传输. 当发送端将数据发出之后会等待对端的确认应答. 如果确认应答, 说明数据已经成功到达对端. 反之, 则数据丢失的可能性很大. 如果在一段时间内没有收到确认应答, 发送端就可以认为数据已经丢失, 并进行重发. 由此, 即使产生了丢包, 仍然可以保证数据可以到达对端, 实现可靠传输.

### 重发超时如何确定

重发超时是指重发数据之前, 等待确认应答到来的那个特定时间间隔. 如果超过了这个时间仍未收到确认应答, 发送端将进行数据重发. 最理想的情况是, 找到一个最小时间, 它能保证`确认应答一定能在这个时间内返回`. 然而这个时间长短随着数据包途径的网络环境的不同而有所变化. TCP 要求无论在何种网络环境下都要提供高性能通信, 并且无论网络拥堵情况发生何种变化都必须保持这一特性. 为此, 它在每次发包时都会计算往返时间及其偏差. 将这个往返时间和偏差相加重发超时的时间, 就是比这个总和稍大一点.

![show](https://image.cjyong.com/blog/tcpip/122.png)

在 BSD 的 Unix 以及 Windows 系统中, 超时都以 0.5 秒为单位进行控制, 因此重发超时都是以 0.5 秒的整数倍. 不过, 由于最初的数据包还不知道往返时间, 所以其重发的时间一般设置为 6 秒左右.

如果数据重发之后还收不到确认应答, 则进行再次发送. 此时等待确认应答时间将会以 2 倍, 4 倍的指数函数延长. 此外, 当数据达到了一定的重发次数之后, 如果还没有任何确认应答返回, 就会判断为网络或对端主机发生了异常, 强制关闭连接, 并通知应用通信异常强行终止.

### 连接管理

TCP 提供了面向有连接的通信传输, 面向有连接是指在数据通信开始之前先做好通信两端之间的准备工作. 为了保证通信可以正确成功建立, TCP 会在数据通信之前, 通过 TCP 首部发送一个 SYN 包作为建立连接请求等待确认应答. 如果对端发来确认应答, 则认为可以进行数据通信. 如果对端的确认应答未能到达, 就不会进行数据通信. 此外, 在通信结束时会进行断开连接的处理(FIN 包).

![show](https://image.cjyong.com/blog/tcpip/123.png)

### TCP 以段为单位发送数据

在建立 TCP 连接的同时, 可以确定发送数据包的单位, 我们称其为`最大消息长度(MSS: Maximum Segment Size)`. 最理想的情况下, 最大消息长度正好是 IP 中不会被分片处理的最大数据长度. 在 TCP 传输大量数据的时候, 是以 MSS 的大小将数据进行分割发送, 进行重发时也是以 MSS 为单位. MSS 是在三次握手的时候, 在两端主机之间被计算得出. 两端主机在发出建立连接请求时, 会在 TCP 首部写入 MSS 选项, 告诉对方自己的接口可以适应的 MSS 的大小. 然后会在两者之间选择一个较小的值投入使用.

![show](https://image.cjyong.com/blog/tcpip/124.png)

### 利用窗口控制提高速度

TCP 以 1 个段为单位, 没法送一个段进行一次确认应答处理. 这样的传输方式存在一个缺点: 如果包的往返时间越长通信性能就越低.

![show](https://image.cjyong.com/blog/tcpip/125.png)

为了解决这个问题, TCP 引用了窗口的概念. 即使是在往返较长的情况下, 也能控制网络性能的下降. \

![show](https://image.cjyong.com/blog/tcpip/126.png)

窗口大小是指在无需确认应答而可以继续发送数据的最大值.在这种机制下, 使用了大量的缓冲区, 通过对多个段同时进行确认应答的功能.

![show](https://image.cjyong.com/blog/tcpip/127.png)

在这种情况下, 窗口内的数据都会被发送出去(而不需要等待确认表示), 如果收到确认应答的位置, 则将窗口滑动到确认应答中的序列号的位置(保证是大小排序的). 这样可以顺序地将多个段同时发送提高通信性能. 这种机制也被称为滑动窗口控制.

### 窗口控制与重发控制

在使用窗口控制中,如果出现段丢失时又会发生什么呢? 对于一些确认应答即使丢失了也无需要重发.

![show](https://image.cjyong.com/blog/tcpip/128.png)

如果接收主机收到了一个自己应该接收的序号外的数据, 会针对当前为止收到的数据返回确认应答.

![show](https://image.cjyong.com/blog/tcpip/129.png)

当其中一份报文丢失的情况, 发送端会一直收到序号为 1001 的确认应答, 这个确认应答好像是在提醒发送端`我想接收的是从1001开始的数据`. 因此, 在窗口较大, 又出现报文丢失后, 同一个序号确认应答将会被重复不断地返回. 如果发送主机连续 3 次收到同一个确认应答, 就会将所对应的数据进行重发. 这种机制比之前提到的超时管理更加高效, 因此也被称作高速重发控制(Fast Retransmission).

### 流控制

在发送端使用窗口控制发送数据时, 如果发送的数据包过多, 接收端无法第一时间处理完毕(某些包更是需要进行特殊耗时处理). 这就会导致丢包,从而触发重发机制, 导致网络流量的无端浪费.

为了防止这种现象的出现, TCP 提供一种机制可以让发送端根据接收端的实际接收能力控制发送的数据量. 这就是所谓的流控制.它的具体操作是, 接收端主机向发送端主机通知自己可以接收数据的大小(通过设置 TCP 首部中一个专门的字段), 于是发送端会发送不超过这个限度的数据.

![show](https://image.cjyong.com/blog/tcpip/130.png)

### 拥塞控制

TCP 的窗口控制中, 收发主机之间即使不再以一个数据段为单位发送确认应答, 也能够连续发送大量数据包. 然而, 如果在通信刚开始就发送大量数据, 就可能引发其他问题. 一般来说, 计算机网络处于一个共享的环境, 因此有可能因为其他主机之间的通信导致网络拥堵. 当网络出现拥堵时, 如果突然发送一个较大量的数据, 就可能导致整个网络的瘫痪.

TCP 为了防止这种问题的出现, 在通信的一开始就会通过一个叫做慢启动的算法得出数值, 对发送数据量进行控制.

![show](https://image.cjyong.com/blog/tcpip/131.png)

首先, 为了在发送端调节所需要发送数据的量, 定义了一个叫做`拥堵窗口`的概念, 于是在慢启动的时候, 将这个拥塞窗口的大小设置为 1 个数据段发送数据, 之后每收到一次确认应答(ACK), 拥塞窗口的值就加 1. 在发送数据包的时候, 将拥塞窗口的大小与接收端主机通知的窗口大小进行比较, 取较小值进行发送.

随着包的往返, 拥塞窗口会以 1,2,4 等指数函数增长, 为了防止增长过快导致网络拥塞的发生, 设置了一个比例阈值(最大只能按照这个阈值进行放大范围): 1 个数据段的字节数 \* 1 个数据段字节数 / 拥塞窗口(字节).

当 TCP 通信开始时,没有设置相应的慢启动阈值. 而是在超时重发时, 才会设置为当时拥塞窗口的一半. 由重复确认应答而出发的高速重发与超时重发机制处理多少有些不同. 因为前者要求至少 3 次的确认应答数据到达对方主机才会触发, 相比后者网络的拥堵要轻一点.而由重复确认应答进行高速重发控制时, 慢启动阈值的大小被设置为当时窗口大小的一般. 然后将窗口的大小设置为该慢启动阈值+3 个数据段大小.

当 TCP 通信开始, 网络吞吐量会逐渐上升, 随着网络拥堵的发生, 吞吐量也会急速下降. 于是会再次进入吞吐量慢慢上升的过程. 因此所谓的 TCP 的吞吐量的特点就好像是在逐渐占领网络带宽的感觉.

### 提高网络利用率的规范

#### Nagle 算法

TCP 中为了提高网络的利用率, 经常使用一个叫做 Nagle 的算法: 如果发送端还有应该发送的数据, 但是如果这部分数据很少的话, 可以进行延迟发送的一种机制. 虽然这个算法可以提高利用率, 但是可能会发生某种程度的延迟. 所以在窗口控制以及机械控制等领域中使用 TCP 时, 往往会关闭对算法的启用.

#### 延迟确认应答

接收数据的主机如果每次都立刻回复确认应答, 可能会返回一个较小的窗口. 那是因为刚接收完数据, 缓冲区已满. 这里引入了一个新的方法, 那就是接收到数据之后不会立刻返回确认应答, 而是延迟一段时间机制.

- 在没有收到 2x 最大段长度的数据为止不做确认应答.(有时无论数据大小, 只要收到两个包立刻返回确认应答, 一个不回).
- 其他情况下, 最大延迟 0.5 秒发送确认应答.

#### 捎带应答

根据应用层协议, 发送出去的消息到达对端,对端进行处理以后, 会返回一个回执. 如远程登录中针对输入的字符进行回送校验也是针对发送消息的一种回执.

在此类通信中, TCP 的确认应答和回执数据可以通过一个包发送. 这种方式叫做捎带应答(PiggyBack Acknowledgement). 通过这种机制, 可以使收发的数据量减少.

另外, 接收数据以后如果立刻返回确认应答, 就无法捎带应答. 而是将接收的数据传给应用处理生成返回数据以后进再进行发送请求为止, 必须一直等待确认应答的发送. 也就是说, 如果没有启用延迟确认应答就无法实现捎带应答. 延迟确认应答是可以提高网络利用率从而降低计算机处理负荷的一种较优的处理机制.

![show](https://image.cjyong.com/blog/tcpip/132.png)

## 其他传输层协议

在互联网中, 很长一段时间内主要使用的传输层协议是 TCP 和 UDP 两种. 然而, 除了这两个协议外还有其他几种传输层协议曾经被提案并进行了实验. 这里简介几种被广泛被使用的传输层协议.

### UDP-Lite

UDP-Lite(Lightweight User Datagram Protocol, 轻量级用户数据报协议)是拓展 UDP 机能的一种传输层协议. 在基于 UDP 的通信当中如果出现校验和出现错误, 所收到的包将被全部丢弃. 然而, 现实操作中, 有些应用在面对这种情况时并不希望把已经收到的所有包丢弃.

如果将 UDP 中校验和设置为无效, 那么即使数据的一部分发生错误也不会将整个包废弃. 不过, 这也存在问题: 如果 UDP 首部中的端口号被破坏或是 IP 首部中的 IP 地址被破坏, 就会发生严重后果. 因此不建议将校验和关闭. 为了解决这些问题, UDP 的修正版 UDP-Lite 协议就出现了. UDP-Lite 提供与 UDP 几乎相同的功能, 不过计算校验和的范围可以由应用自行决定. 这个范围可以是包加上伪首部的校验和计算, 可以是首部与伪首部的校验和, 也可以是首部, 伪首部与数据从起始到中间某个位置的校验和计算. 有了这样的机制, 就可以只针对不允许发生错误的部分进行校验和的检查. 对于其他部分, 即使发生了错误也会被忽略不计, 而这个包也不会被丢弃, 而是直接传给应用继续处理.

### SCTP

SCTP(Stream Control Transmission Protocol, 流控制传输协议)与 TCP 一样, 都是对一种提供数据到达与否相关可靠性检查的传输层协议.其主要特点:

- 以消息为单位收发, TCP 中接收端并不知道发送端应用所决定的消息大小.在 SCTP 中却可以.
- 支持多重宿主: 在多个 NIC 的主机中, 即使其中能够使用的 NIC 发生变化, 也仍然可以继续通信.
- 支持多数据流通信: 在 TCP 中建立多个连接以后才能进行通信的效果, 在 SCTP 中一个连接就可以.
- 可以定义消息的生存期限: 超过生存期限的消息, 不会被重发.

SCTP 主要用于进行通信的应用之间发送众多较小消息的情况. 这些较小的应用消息被称作数据块(Chunk), 多个数据块组成一个数据包. 此外, SCTP 具有支持多重宿主以及设定多个 IP 地址的特点. 多重宿主是指同一台主机具备多种网络的接口.如: 笔记本电脑既可以连接以太网又可以连接无线 LAN.

然而在 SCTP 的情况下, 由于可以管理多个 IP 地址使其同时进行通信, 因此即使出现通信过程当中以太网与无线 LAN 之间的切换, 可以保持通信不中断. 所以 SCTP 可以具备多个 NIC 的主机提供更可靠的传输.

### DCCP

DCCP(Datagram Congestion Control Protocol, 数据报拥塞控制协议)是一个辅助 UDP 的崭新的传输层协议. UDP 没有拥塞控制机制, 为此, 当应用使用 UDP 发送大量数据包时极容易出现问题. 互联网中的通信, 即使使用 UDP 也应该控制拥塞. 而这个机制开发人员很难将其融合到协议中, 于是出现了 DCCP 这样的规范.DCCP 具有如下几个特点:

- 与 UDP 一样, 不能提供发送数据的可靠性传输.
- 面向连接, 具备建立连接与断开连接的处理. 在建立和断开连接上是具有可靠性.
- 可以根据网络拥堵情况进行拥塞控制. 使用 DCCP 可以根据自身特点选择两种方法进行拥塞控制, 分别是`类似TCP(TCP-Like)拥塞控制`和`TCP友好升级控制`.
- 为了进行拥塞控制, 接收端收到包以后返回确认应答(ACK). 该确认应答被用于重发与否的判断.

## UDP 首部的格式

如图这些首部数据部分为源端口号, 目标端口号, 包长度和校验和.

![show](https://image.cjyong.com/blog/tcpip/133.png)

源端口号: 表示发送端口号, 字段长 16 位. 该字段是可选项, 有时可能不会设置源端口号. 没有源端口号的时候该字段的值设置为 0.
目标端口号: 接收端端口, 字段长度 16 位.
包长度: 该字段保存了 UDP 首部的长度和数据的长度之和. 单位为字节(8 字节).
校验和: 校验和是为了提供可靠的 UDP 首部和数据而设计. 在计算校验和时, 附加到 UDP 伪首部与 UDP 数据报之前, 通过在最后一位增加一个`0`增加到 16 倍. 此时将 UDP 首部的校验和字段设置为`0`. 然后以 16 比特为单位进行 1 的补码和, 并将所得到的 1 的补码写入到校验和字段.

## TCP 首部格式

TCP 首部相比 UDP 首部要复杂很多. 另外 TCP 中没有表示包长度和数据长度的字段. 可由 IP 层获知 TCP 包长.

![show](https://image.cjyong.com/blog/tcpip/135.png)

- 源端口号(Source Port): 发送端端口号, 字段长 16 位.
- 目标端口号(Destination Port): 目标端口号, 字段长 16 位.
- 序列号(Sequence Number): 字段长 32 为. 序列号是指发送数据的位置. 每次发送一次, 就累加一次该数据字节数的大小.
- 确认应答号(Acknowledgement Number): 确认应答号字段号长度 32 位. 实际上, 它是指确认应答号减一为止的数据. 发送端收到这个确认应答以后可以认为这个序号以前的数据都已经被正常接收.
- 数据偏移(Data Offset): 该字段表示 TCP 所传输的数据部分应该从 TCP 包的那个位开始计算, 当然也可以把它看作 TCP 首部长度. 该字段长 4 位, 单位为 4 字节. 不包括选项字段的话.
- 保留(Reserved): 该字段主要是为了以后拓展时使用, 其长度为 4 位. 一般设置为 0, 即使收到的包的该字段不为 0, 此包也不会被丢弃.
- 控制位(Control Flag): 字段长 8 位, 每一位从左到右分别为 CWR, ECE, URG, ACK, PSH, RST, SYN, FIN. 这些控制也做控制位.
  - CWR(Congestion Window Reduced): CWR 标志与后面的 ECE 标志都用于 IP 首部的 ECN 字段. ECE 标志为 1 时, 则通知对方已将拥塞窗口缩小.
  - ECE(ECN-Echo): ECE 标志表示 ECN-Echo, 置为 1 会通知通信对方, 从对方到这边网络有堵塞. 收到数据包的 IP 首部中 ECN 为 1 将 TCP 首部中 ECE 设置为 1.
  - URG(Urgent Flag): 该位为 1 时, 表示包中有紧急处理的数据, 对于需要紧急处理的数据, 会在后面的紧急指针进行解释.
  - ACK(Acknowledgement Flag): 该位为 1 时, 确认应答的字段变为有效. TCP 规定除了最初建立连接时 SYN 包之外该位必须设置为 1.
  - PSH(Push Flag): 该位为 1 时, 需要将受到的数据立刻传给上层应用协议, PSH 为 0 时则不需要立即传而是先进行缓存.
  - RST(Reset Flag): 该位设置为 1 时, 表示 TCP 连接中出现异常必须强制断开连接.
  - SYN(Synchronize Flag): 用于建立连接, SYN 为 1 表示希望建立连接, 并在其序列号的字段进行序列号初始值的设定.
  - FIN(Fin Flag): 该位为 1 时, 表示今后不会再有数据发送, 希望断开连接. 当通信结束希望断开连接时, 通信双方的主机之间就可以相互交换 FIN 位置为 1 的 TCP 段.每个主机又对对方的 FIN 包进行确认应答以后就可以断开连接.不过, 主机接收到 FIN 设置为 1 的 TCP 段以后不必马上回复一个 FIN 包, 而是可以等到缓冲区中的所有数据都因已成功发送而自动删除之后再发.
- 窗口大小(Window Size): 该字段长为 16 位, 用于通知从相同 TCP 首部的确认应答号所指位置开始能够接收的数据大小(8 位字节). TCP 不允许发送超过此处所示大小的数据. 不过如果窗口为 0, 则表示可以发送窗口探测, 以了解最新的窗口大小, 但是这个数据必须是 1 个字节.
- 校验和(Checksum): 类似 UDP, 但是 TCP 的校验和无法关闭.
- 紧急指针(Urgent Pointer): 该字段长为 16 位, 只有在 URG 控制位为 1 时有效. 该字段的数值表示本报文段中紧急数据的指针. 正确来讲, 从数据部分的首位到紧急指针所指示的位置为止为紧急数据. 该处的应用一般为应用的问题, 一般用于暂时中断通信时使用.
- 选项(Options): 用于提高 TCP 的传输性能. 根据数据偏移进行控制, 所以其长度最大为 40 字节. 并且选项字段尽量调整为 32 位的整数倍. 其代表性选项如下:

![show](https://image.cjyong.com/blog/tcpip/136.png)

### 窗口大小和吞吐量

TCP 通信的最大吞吐量由窗口大小和往返时间决定. 假定最大吞吐量为 T, 窗口大小为 W, 往返时间为 RTT, 则吞吐量为: T = W / RTT. 假设窗口大小为 65535 字节, RTT 为 0.1 秒, 则最大吞吐量为 T = W / RTT = 65535 \* 8(比特) / 0.1(秒) = 5242800 bps = 5.2 Mbps. 这就表示一个 TCP 连接可以达到最大的吞吐量为 5.2Mbps. 如果建立两个以上连接同时进行传输, 则彼此吞吐量则会翻倍. 在 TCP 中为了提高网络吞吐量可以建立多个连接来提高吞吐量, Web 浏览器中一般建立 4 个左右的连接来提高吞吐量.
