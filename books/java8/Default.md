## 默认方法

#### 问题的产生
传统中的Java接口: 接口是将相关方法按照约定组合到一起的方式. 实现接口的类必须为接口中定义的每一个方法提供一个实现, 或者从父类中继承它的实现. 但是, 一旦类库的设计者更新了接口, 添加了新的方法, 这种方式就会带来一个严重的问题. 现实中, 已经使用旧版接口实现的类, 就需要全部重写, 添加新的接口方法的实现. 如果接口添加的数量较少, 实现的类也较少, 还是可以实现的. 如果接口实现添加了非常多, 这几乎就是不可能实现的的事情.

#### 解决方案
+ Java8允许接口内声明静态方法.
+ Java8引入默认方法, 通过默认方法, 我们可以指定接口方法的默认实现. 即: 如果实现了给接口的类, 没有实现该默认方法, 就会使用默认的实现方法.

##### 不同类型的兼容性
1. 二进制级的兼容性: 表示现有的二进制执行文件可以无缝持续连接(包括验证, 准备和解析)和运行. 如: 向一个接口添加一个方法, 就是二进制级的兼容. 在这种情况下, 新添加的方法如果不被调用, 接口已经实现的方法可以继续运行, 不会出现错误.
2. 源代码级的兼容性: 引入变化后, 现有的程序依然能够成功编译通过. 比如: 向一个接口添加一个方法就不是源码级的兼容, 因为遗留代码并没有实现新引入的方法, 代码无法顺利通过编译.
3. 函数行为的兼容性: 引入变化后, 程序接受同样的输入, 可以得到同样的接口. 如: 向一个接口添加一个方法是函数行为兼容的, 因为新添加的方法在程序中并未调用.

#### 默认方法的使用模式

+ 可选方法: 如某个类实现了某个接口, 但是我们却刻意将一些方法留白. 如: Iterator接口为例, Iterator接口定义了haxNext, next, remove方法, 用户通常不会使用remove方法, 我们实现Iterator接口之后常常将该方法空实现. 使用默认方法, 我们就可以为该方法进行默认实现. 这样子, 我们实现Iterator接口时, 就不用实现remove方法.
+ 行为的多继承: 
```java
public class ArrayList<E> extends AbstractList<E>
        implements List<E>, RandomAccess, Cloneable, java.io.Serializable{
        ...
}
```
继承只可以继承一个类, 通过接口我们可以定制不同的行为接口, 并为每一个接口实现默认的方法, 如果某个类希望使用该行为, 只要继承该类就可以了. 
> 继承不应该成为代码复用的万金油. 如果一个类拥有100个及以上方法或者字段时, 对该类进行继承就不是一个好主意, 因为这会引入不必要的复杂性.

#### 解决冲突的规则
当一个类继承了多个方法, 而它们使用的缺失同样的函数签名. 这种情况下, 就会产生矛盾, 类实际应该使用哪个接口默认实现的方法? 有三条规则:
1. 类中的方法优先级最高. 类或者父类中声明的方法优先级高于任何声明为默认方法的优先级.
2. 如果无法依据第一条进行判断, 那么子接口的优先级更高.如: B继承了A, 那么B接口中的方法优先级要高于A接口中的默认方法.
3. 最后还无法进行判断, 继承了多个接口的类必须通过显示覆盖和调用期望的方法. 如
```java
public interface A{
	default void hello(){
    	System.out.println("12");
    }
}
public interface B{
	default void hello(){
    	System.out.println("34");
    }
}
public class C implements A, B{
	public static void main (String ... args){
    	new D().hello(); // 如果没有添加后面的hello方法, 将会编译失败, 无法确定优先级.
    }
    //解决冲突:
    void hello(){
    	B.super.hello();
    }
}
```